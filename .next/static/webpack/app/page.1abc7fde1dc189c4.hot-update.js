"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/page",{

/***/ "(app-pages-browser)/./components/portrait/useImageMesh.ts":
/*!*********************************************!*\
  !*** ./components/portrait/useImageMesh.ts ***!
  \*********************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   useImageMesh: function() { return /* binding */ useImageMesh; }\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);\n/* __next_internal_client_entry_do_not_use__ useImageMesh auto */ \n// Sobel edge detection kernels\nconst SOBEL_X = [\n    [\n        -1,\n        0,\n        1\n    ],\n    [\n        -2,\n        0,\n        2\n    ],\n    [\n        -1,\n        0,\n        1\n    ]\n];\nconst SOBEL_Y = [\n    [\n        -1,\n        -2,\n        -1\n    ],\n    [\n        0,\n        0,\n        0\n    ],\n    [\n        1,\n        2,\n        1\n    ]\n];\n// Gaussian blur kernel for noise reduction\nconst GAUSSIAN_3x3 = [\n    [\n        1 / 16,\n        2 / 16,\n        1 / 16\n    ],\n    [\n        2 / 16,\n        4 / 16,\n        2 / 16\n    ],\n    [\n        1 / 16,\n        2 / 16,\n        1 / 16\n    ]\n];\nfunction getPixelGrayscale(imageData, x, y) {\n    const idx = (y * imageData.width + x) * 4;\n    const r = imageData.data[idx];\n    const g = imageData.data[idx + 1];\n    const b = imageData.data[idx + 2];\n    // Luminance formula\n    return 0.299 * r + 0.587 * g + 0.114 * b;\n}\nfunction applyKernel(grayscale, width, height, x, y, kernel) {\n    let sum = 0;\n    for(let ky = -1; ky <= 1; ky++){\n        for(let kx = -1; kx <= 1; kx++){\n            const px = Math.min(Math.max(x + kx, 0), width - 1);\n            const py = Math.min(Math.max(y + ky, 0), height - 1);\n            const gray = grayscale[py * width + px];\n            sum += gray * kernel[ky + 1][kx + 1];\n        }\n    }\n    return sum;\n}\nfunction detectEdges(imageData) {\n    const width = imageData.width;\n    const height = imageData.height;\n    // Convert to grayscale\n    const grayscale = new Float32Array(width * height);\n    for(let y = 0; y < height; y++){\n        for(let x = 0; x < width; x++){\n            grayscale[y * width + x] = getPixelGrayscale(imageData, x, y);\n        }\n    }\n    // Apply Gaussian blur to reduce noise\n    const blurred = new Float32Array(width * height);\n    for(let y = 1; y < height - 1; y++){\n        for(let x = 1; x < width - 1; x++){\n            blurred[y * width + x] = applyKernel(grayscale, width, height, x, y, GAUSSIAN_3x3);\n        }\n    }\n    // Apply Sobel operator\n    const edges = new Float32Array(width * height);\n    const directions = new Float32Array(width * height);\n    for(let y = 1; y < height - 1; y++){\n        for(let x = 1; x < width - 1; x++){\n            const gx = applyKernel(blurred, width, height, x, y, SOBEL_X);\n            const gy = applyKernel(blurred, width, height, x, y, SOBEL_Y);\n            const magnitude = Math.sqrt(gx * gx + gy * gy);\n            edges[y * width + x] = magnitude;\n            directions[y * width + x] = Math.atan2(gy, gx);\n        }\n    }\n    // Non-maximum suppression for thinner edges\n    const suppressed = new Float32Array(width * height);\n    for(let y = 2; y < height - 2; y++){\n        for(let x = 2; x < width - 2; x++){\n            const angle = directions[y * width + x];\n            const mag = edges[y * width + x];\n            // Get neighbors in gradient direction\n            let neighbor1 = 0, neighbor2 = 0;\n            const normalizedAngle = (angle + Math.PI) / Math.PI * 4 % 4;\n            if (normalizedAngle < 1 || normalizedAngle >= 3) {\n                // Horizontal\n                neighbor1 = edges[y * width + (x - 1)];\n                neighbor2 = edges[y * width + (x + 1)];\n            } else if (normalizedAngle >= 1 && normalizedAngle < 2) {\n                // Diagonal /\n                neighbor1 = edges[(y - 1) * width + (x + 1)];\n                neighbor2 = edges[(y + 1) * width + (x - 1)];\n            } else {\n                // Diagonal \\\n                neighbor1 = edges[(y - 1) * width + (x - 1)];\n                neighbor2 = edges[(y + 1) * width + (x + 1)];\n            }\n            // Keep only local maxima\n            if (mag >= neighbor1 && mag >= neighbor2) {\n                suppressed[y * width + x] = mag;\n            }\n        }\n    }\n    return {\n        edges: suppressed,\n        directions\n    };\n}\nfunction sampleEdgePoints(edges, width, height, threshold, density, maxPoints) {\n    const points = [];\n    // Normalize edges to 0-255 range for better thresholding\n    let maxEdge = 0;\n    for(let i = 0; i < edges.length; i++){\n        if (edges[i] > maxEdge) maxEdge = edges[i];\n    }\n    const normalizedThreshold = threshold / 255 * maxEdge;\n    // Adaptive sampling - smaller step for denser point coverage\n    const baseStep = Math.max(2, Math.floor(1 / density));\n    // Sample points along edges with adaptive density\n    for(let y = baseStep; y < height - baseStep; y += baseStep){\n        for(let x = baseStep; x < width - baseStep; x += baseStep){\n            const edgeValue = edges[y * width + x];\n            if (edgeValue > normalizedThreshold) {\n                // Stronger edges get points more reliably\n                const strength = edgeValue / maxEdge;\n                // Add slight jitter for organic look, less jitter for strong edges\n                const jitterAmount = baseStep * 0.3 * (1 - strength * 0.5);\n                const jitterX = (Math.random() - 0.5) * jitterAmount;\n                const jitterY = (Math.random() - 0.5) * jitterAmount;\n                points.push({\n                    x: x + jitterX,\n                    y: y + jitterY,\n                    id: points.length\n                });\n                // For very strong edges, add additional nearby points for detail\n                if (strength > 0.6 && Math.random() > 0.5) {\n                    const offsetX = (Math.random() - 0.5) * baseStep;\n                    const offsetY = (Math.random() - 0.5) * baseStep;\n                    points.push({\n                        x: x + offsetX,\n                        y: y + offsetY,\n                        id: points.length\n                    });\n                }\n            }\n        }\n    }\n    // Add grid points for better coverage (sparse background mesh)\n    const gridStep = Math.max(25, width / 12);\n    for(let y = gridStep; y < height - gridStep; y += gridStep){\n        for(let x = gridStep; x < width - gridStep; x += gridStep){\n            // Only add if not too close to existing edge points\n            const hasNearby = points.some((p)=>Math.abs(p.x - x) < gridStep * 0.4 && Math.abs(p.y - y) < gridStep * 0.4);\n            if (!hasNearby) {\n                points.push({\n                    x,\n                    y,\n                    id: points.length\n                });\n            }\n        }\n    }\n    // Add boundary points for better triangulation\n    const boundaryStep = Math.max(15, width / 20);\n    for(let x = 0; x <= width; x += boundaryStep){\n        points.push({\n            x,\n            y: 0,\n            id: points.length\n        });\n        points.push({\n            x,\n            y: height,\n            id: points.length\n        });\n    }\n    for(let y = boundaryStep; y < height; y += boundaryStep){\n        points.push({\n            x: 0,\n            y,\n            id: points.length\n        });\n        points.push({\n            x: width,\n            y,\n            id: points.length\n        });\n    }\n    // Add corner points\n    points.push({\n        x: 0,\n        y: 0,\n        id: points.length\n    });\n    points.push({\n        x: width,\n        y: 0,\n        id: points.length\n    });\n    points.push({\n        x: 0,\n        y: height,\n        id: points.length\n    });\n    points.push({\n        x: width,\n        y: height,\n        id: points.length\n    });\n    // Limit points if too many, prioritizing edge points\n    if (points.length > maxPoints) {\n        // Sort by how close they are to strong edges (approximate by keeping earlier points)\n        const edgePointCount = points.length - Math.floor(width / boundaryStep) * 2 - Math.floor(height / boundaryStep) * 2 - 4;\n        const boundaryPoints = points.slice(edgePointCount);\n        const edgePoints = points.slice(0, edgePointCount);\n        // Keep a good sample of edge points\n        const sampledEdge = edgePoints.sort(()=>Math.random() - 0.5).slice(0, maxPoints - boundaryPoints.length);\n        return [\n            ...sampledEdge,\n            ...boundaryPoints\n        ].map((p, i)=>({\n                ...p,\n                id: i\n            }));\n    }\n    return points;\n}\n// Delaunay triangulation using Bowyer-Watson algorithm\nfunction delaunayTriangulate(points, width, height) {\n    if (points.length < 3) return [];\n    // Create super triangle that contains all points\n    const margin = Math.max(width, height) * 3;\n    const superPoints = [\n        {\n            x: width / 2,\n            y: -margin,\n            id: -1\n        },\n        {\n            x: -margin,\n            y: height + margin,\n            id: -2\n        },\n        {\n            x: width + margin,\n            y: height + margin,\n            id: -3\n        }\n    ];\n    let triangles = [\n        {\n            p1: superPoints[0],\n            p2: superPoints[1],\n            p3: superPoints[2]\n        }\n    ];\n    // Add points one at a time\n    for (const point of points){\n        const badTriangles = [];\n        // Find all triangles whose circumcircle contains the point\n        for (const triangle of triangles){\n            if (isPointInCircumcircle(point, triangle)) {\n                badTriangles.push(triangle);\n            }\n        }\n        // If no bad triangles found, skip this point\n        if (badTriangles.length === 0) continue;\n        // Find the boundary of the polygonal hole\n        const polygon = [];\n        for (const triangle of badTriangles){\n            const edges = [\n                {\n                    p1: triangle.p1,\n                    p2: triangle.p2\n                },\n                {\n                    p1: triangle.p2,\n                    p2: triangle.p3\n                },\n                {\n                    p1: triangle.p3,\n                    p2: triangle.p1\n                }\n            ];\n            for (const edge of edges){\n                // Check if edge is shared with another bad triangle\n                let isShared = false;\n                for (const other of badTriangles){\n                    if (other === triangle) continue;\n                    if (hasEdge(other, edge)) {\n                        isShared = true;\n                        break;\n                    }\n                }\n                if (!isShared) {\n                    polygon.push(edge);\n                }\n            }\n        }\n        // Remove bad triangles\n        triangles = triangles.filter((t)=>!badTriangles.includes(t));\n        // Create new triangles from polygon edges to point\n        for (const edge of polygon){\n            triangles.push({\n                p1: edge.p1,\n                p2: edge.p2,\n                p3: point\n            });\n        }\n    }\n    // Remove triangles that share vertices with super triangle\n    triangles = triangles.filter((t)=>t.p1.id >= 0 && t.p2.id >= 0 && t.p3.id >= 0);\n    return triangles;\n}\n// Calculate circumcircle and check if point is inside\nfunction isPointInCircumcircle(point, triangle) {\n    const { p1, p2, p3 } = triangle;\n    // Calculate the circumcenter\n    const d = 2 * (p1.x * (p2.y - p3.y) + p2.x * (p3.y - p1.y) + p3.x * (p1.y - p2.y));\n    if (Math.abs(d) < 1e-10) return false // Degenerate triangle\n    ;\n    const ux = ((p1.x * p1.x + p1.y * p1.y) * (p2.y - p3.y) + (p2.x * p2.x + p2.y * p2.y) * (p3.y - p1.y) + (p3.x * p3.x + p3.y * p3.y) * (p1.y - p2.y)) / d;\n    const uy = ((p1.x * p1.x + p1.y * p1.y) * (p3.x - p2.x) + (p2.x * p2.x + p2.y * p2.y) * (p1.x - p3.x) + (p3.x * p3.x + p3.y * p3.y) * (p2.x - p1.x)) / d;\n    // Circumradius squared\n    const radiusSq = (p1.x - ux) * (p1.x - ux) + (p1.y - uy) * (p1.y - uy);\n    // Distance from point to circumcenter squared\n    const distSq = (point.x - ux) * (point.x - ux) + (point.y - uy) * (point.y - uy);\n    return distSq <= radiusSq;\n}\nfunction hasEdge(triangle, edge) {\n    const points = [\n        triangle.p1,\n        triangle.p2,\n        triangle.p3\n    ];\n    let hasP1 = false;\n    let hasP2 = false;\n    for (const p of points){\n        if (p.id === edge.p1.id) hasP1 = true;\n        if (p.id === edge.p2.id) hasP2 = true;\n    }\n    return hasP1 && hasP2;\n}\nfunction useImageMesh(config) {\n    const { imageSrc, width, height, edgeThreshold = 50, pointDensity = 0.08, maxPoints = 500 } = config;\n    const [mesh, setMesh] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)({\n        points: [],\n        triangles: []\n    });\n    const [isLoading, setIsLoading] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(true);\n    const [error, setError] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(null);\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        if (!imageSrc) {\n            setIsLoading(false);\n            return;\n        }\n        const processImage = async ()=>{\n            setIsLoading(true);\n            setError(null);\n            try {\n                // Create image element\n                const img = new Image();\n                // Don't set crossOrigin for local images\n                if (imageSrc.startsWith(\"http\")) {\n                    img.crossOrigin = \"anonymous\";\n                }\n                await new Promise((resolve, reject)=>{\n                    img.onload = ()=>{\n                        console.log(\"Image loaded successfully:\", img.width, img.height);\n                        resolve();\n                    };\n                    img.onerror = (e)=>{\n                        console.error(\"Image load error:\", e);\n                        reject(new Error(\"Failed to load image\"));\n                    };\n                    img.src = imageSrc;\n                });\n                // Create canvas and draw image\n                const canvas = document.createElement(\"canvas\");\n                canvas.width = width;\n                canvas.height = height;\n                const ctx = canvas.getContext(\"2d\");\n                if (!ctx) {\n                    throw new Error(\"Could not get canvas context\");\n                }\n                // Draw image scaled to canvas size\n                ctx.drawImage(img, 0, 0, width, height);\n                // Get image data\n                const imageData = ctx.getImageData(0, 0, width, height);\n                // Detect edges\n                const { edges } = detectEdges(imageData);\n                console.log(\"Edges detected, max value:\", Math.max(...edges));\n                // Sample points along edges\n                const points = sampleEdgePoints(edges, width, height, edgeThreshold, pointDensity, maxPoints);\n                console.log(\"Points sampled:\", points.length);\n                // Create triangles using Delaunay triangulation\n                const triangles = delaunayTriangulate(points, width, height);\n                console.log(\"Triangles created:\", triangles.length);\n                setMesh({\n                    points,\n                    triangles\n                });\n            } catch (err) {\n                console.error(\"useImageMesh error:\", err);\n                setError(err instanceof Error ? err.message : \"Unknown error\");\n                // Fallback to empty mesh\n                setMesh({\n                    points: [],\n                    triangles: []\n                });\n            } finally{\n                setIsLoading(false);\n            }\n        };\n        processImage();\n    }, [\n        imageSrc,\n        width,\n        height,\n        edgeThreshold,\n        pointDensity,\n        maxPoints\n    ]);\n    return {\n        mesh,\n        isLoading,\n        error\n    };\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL2NvbXBvbmVudHMvcG9ydHJhaXQvdXNlSW1hZ2VNZXNoLnRzIiwibWFwcGluZ3MiOiI7Ozs7OztrRUFFMkM7QUFZM0MsK0JBQStCO0FBQy9CLE1BQU1FLFVBQVU7SUFDZDtRQUFDLENBQUM7UUFBRztRQUFHO0tBQUU7SUFDVjtRQUFDLENBQUM7UUFBRztRQUFHO0tBQUU7SUFDVjtRQUFDLENBQUM7UUFBRztRQUFHO0tBQUU7Q0FDWDtBQUVELE1BQU1DLFVBQVU7SUFDZDtRQUFDLENBQUM7UUFBRyxDQUFDO1FBQUcsQ0FBQztLQUFFO0lBQ1o7UUFBQztRQUFHO1FBQUc7S0FBRTtJQUNUO1FBQUM7UUFBRztRQUFHO0tBQUU7Q0FDVjtBQUVELDJDQUEyQztBQUMzQyxNQUFNQyxlQUFlO0lBQ25CO1FBQUMsSUFBRTtRQUFJLElBQUU7UUFBSSxJQUFFO0tBQUc7SUFDbEI7UUFBQyxJQUFFO1FBQUksSUFBRTtRQUFJLElBQUU7S0FBRztJQUNsQjtRQUFDLElBQUU7UUFBSSxJQUFFO1FBQUksSUFBRTtLQUFHO0NBQ25CO0FBRUQsU0FBU0Msa0JBQ1BDLFNBQW9CLEVBQ3BCQyxDQUFTLEVBQ1RDLENBQVM7SUFFVCxNQUFNQyxNQUFNLENBQUNELElBQUlGLFVBQVVJLEtBQUssR0FBR0gsQ0FBQUEsSUFBSztJQUN4QyxNQUFNSSxJQUFJTCxVQUFVTSxJQUFJLENBQUNILElBQUk7SUFDN0IsTUFBTUksSUFBSVAsVUFBVU0sSUFBSSxDQUFDSCxNQUFNLEVBQUU7SUFDakMsTUFBTUssSUFBSVIsVUFBVU0sSUFBSSxDQUFDSCxNQUFNLEVBQUU7SUFDakMsb0JBQW9CO0lBQ3BCLE9BQU8sUUFBUUUsSUFBSSxRQUFRRSxJQUFJLFFBQVFDO0FBQ3pDO0FBRUEsU0FBU0MsWUFDUEMsU0FBdUIsRUFDdkJOLEtBQWEsRUFDYk8sTUFBYyxFQUNkVixDQUFTLEVBQ1RDLENBQVMsRUFDVFUsTUFBa0I7SUFFbEIsSUFBSUMsTUFBTTtJQUNWLElBQUssSUFBSUMsS0FBSyxDQUFDLEdBQUdBLE1BQU0sR0FBR0EsS0FBTTtRQUMvQixJQUFLLElBQUlDLEtBQUssQ0FBQyxHQUFHQSxNQUFNLEdBQUdBLEtBQU07WUFDL0IsTUFBTUMsS0FBS0MsS0FBS0MsR0FBRyxDQUFDRCxLQUFLRSxHQUFHLENBQUNsQixJQUFJYyxJQUFJLElBQUlYLFFBQVE7WUFDakQsTUFBTWdCLEtBQUtILEtBQUtDLEdBQUcsQ0FBQ0QsS0FBS0UsR0FBRyxDQUFDakIsSUFBSVksSUFBSSxJQUFJSCxTQUFTO1lBQ2xELE1BQU1VLE9BQU9YLFNBQVMsQ0FBQ1UsS0FBS2hCLFFBQVFZLEdBQUc7WUFDdkNILE9BQU9RLE9BQU9ULE1BQU0sQ0FBQ0UsS0FBSyxFQUFFLENBQUNDLEtBQUssRUFBRTtRQUN0QztJQUNGO0lBQ0EsT0FBT0Y7QUFDVDtBQUVBLFNBQVNTLFlBQVl0QixTQUFvQjtJQUN2QyxNQUFNSSxRQUFRSixVQUFVSSxLQUFLO0lBQzdCLE1BQU1PLFNBQVNYLFVBQVVXLE1BQU07SUFFL0IsdUJBQXVCO0lBQ3ZCLE1BQU1ELFlBQVksSUFBSWEsYUFBYW5CLFFBQVFPO0lBQzNDLElBQUssSUFBSVQsSUFBSSxHQUFHQSxJQUFJUyxRQUFRVCxJQUFLO1FBQy9CLElBQUssSUFBSUQsSUFBSSxHQUFHQSxJQUFJRyxPQUFPSCxJQUFLO1lBQzlCUyxTQUFTLENBQUNSLElBQUlFLFFBQVFILEVBQUUsR0FBR0Ysa0JBQWtCQyxXQUFXQyxHQUFHQztRQUM3RDtJQUNGO0lBRUEsc0NBQXNDO0lBQ3RDLE1BQU1zQixVQUFVLElBQUlELGFBQWFuQixRQUFRTztJQUN6QyxJQUFLLElBQUlULElBQUksR0FBR0EsSUFBSVMsU0FBUyxHQUFHVCxJQUFLO1FBQ25DLElBQUssSUFBSUQsSUFBSSxHQUFHQSxJQUFJRyxRQUFRLEdBQUdILElBQUs7WUFDbEN1QixPQUFPLENBQUN0QixJQUFJRSxRQUFRSCxFQUFFLEdBQUdRLFlBQVlDLFdBQVdOLE9BQU9PLFFBQVFWLEdBQUdDLEdBQUdKO1FBQ3ZFO0lBQ0Y7SUFFQSx1QkFBdUI7SUFDdkIsTUFBTTJCLFFBQVEsSUFBSUYsYUFBYW5CLFFBQVFPO0lBQ3ZDLE1BQU1lLGFBQWEsSUFBSUgsYUFBYW5CLFFBQVFPO0lBRTVDLElBQUssSUFBSVQsSUFBSSxHQUFHQSxJQUFJUyxTQUFTLEdBQUdULElBQUs7UUFDbkMsSUFBSyxJQUFJRCxJQUFJLEdBQUdBLElBQUlHLFFBQVEsR0FBR0gsSUFBSztZQUNsQyxNQUFNMEIsS0FBS2xCLFlBQVllLFNBQVNwQixPQUFPTyxRQUFRVixHQUFHQyxHQUFHTjtZQUNyRCxNQUFNZ0MsS0FBS25CLFlBQVllLFNBQVNwQixPQUFPTyxRQUFRVixHQUFHQyxHQUFHTDtZQUNyRCxNQUFNZ0MsWUFBWVosS0FBS2EsSUFBSSxDQUFDSCxLQUFLQSxLQUFLQyxLQUFLQTtZQUMzQ0gsS0FBSyxDQUFDdkIsSUFBSUUsUUFBUUgsRUFBRSxHQUFHNEI7WUFDdkJILFVBQVUsQ0FBQ3hCLElBQUlFLFFBQVFILEVBQUUsR0FBR2dCLEtBQUtjLEtBQUssQ0FBQ0gsSUFBSUQ7UUFDN0M7SUFDRjtJQUVBLDRDQUE0QztJQUM1QyxNQUFNSyxhQUFhLElBQUlULGFBQWFuQixRQUFRTztJQUM1QyxJQUFLLElBQUlULElBQUksR0FBR0EsSUFBSVMsU0FBUyxHQUFHVCxJQUFLO1FBQ25DLElBQUssSUFBSUQsSUFBSSxHQUFHQSxJQUFJRyxRQUFRLEdBQUdILElBQUs7WUFDbEMsTUFBTWdDLFFBQVFQLFVBQVUsQ0FBQ3hCLElBQUlFLFFBQVFILEVBQUU7WUFDdkMsTUFBTWlDLE1BQU1ULEtBQUssQ0FBQ3ZCLElBQUlFLFFBQVFILEVBQUU7WUFFaEMsc0NBQXNDO1lBQ3RDLElBQUlrQyxZQUFZLEdBQUdDLFlBQVk7WUFDL0IsTUFBTUMsa0JBQWtCLENBQUVKLFFBQVFoQixLQUFLcUIsRUFBRSxJQUFJckIsS0FBS3FCLEVBQUUsR0FBSSxJQUFJO1lBRTVELElBQUlELGtCQUFrQixLQUFLQSxtQkFBbUIsR0FBRztnQkFDL0MsYUFBYTtnQkFDYkYsWUFBWVYsS0FBSyxDQUFDdkIsSUFBSUUsUUFBU0gsQ0FBQUEsSUFBSSxHQUFHO2dCQUN0Q21DLFlBQVlYLEtBQUssQ0FBQ3ZCLElBQUlFLFFBQVNILENBQUFBLElBQUksR0FBRztZQUN4QyxPQUFPLElBQUlvQyxtQkFBbUIsS0FBS0Esa0JBQWtCLEdBQUc7Z0JBQ3RELGFBQWE7Z0JBQ2JGLFlBQVlWLEtBQUssQ0FBQyxDQUFDdkIsSUFBSSxLQUFLRSxRQUFTSCxDQUFBQSxJQUFJLEdBQUc7Z0JBQzVDbUMsWUFBWVgsS0FBSyxDQUFDLENBQUN2QixJQUFJLEtBQUtFLFFBQVNILENBQUFBLElBQUksR0FBRztZQUM5QyxPQUFPO2dCQUNMLGFBQWE7Z0JBQ2JrQyxZQUFZVixLQUFLLENBQUMsQ0FBQ3ZCLElBQUksS0FBS0UsUUFBU0gsQ0FBQUEsSUFBSSxHQUFHO2dCQUM1Q21DLFlBQVlYLEtBQUssQ0FBQyxDQUFDdkIsSUFBSSxLQUFLRSxRQUFTSCxDQUFBQSxJQUFJLEdBQUc7WUFDOUM7WUFFQSx5QkFBeUI7WUFDekIsSUFBSWlDLE9BQU9DLGFBQWFELE9BQU9FLFdBQVc7Z0JBQ3hDSixVQUFVLENBQUM5QixJQUFJRSxRQUFRSCxFQUFFLEdBQUdpQztZQUM5QjtRQUNGO0lBQ0Y7SUFFQSxPQUFPO1FBQUVULE9BQU9PO1FBQVlOO0lBQVc7QUFDekM7QUFFQSxTQUFTYSxpQkFDUGQsS0FBbUIsRUFDbkJyQixLQUFhLEVBQ2JPLE1BQWMsRUFDZDZCLFNBQWlCLEVBQ2pCQyxPQUFlLEVBQ2ZDLFNBQWlCO0lBRWpCLE1BQU1DLFNBQWtCLEVBQUU7SUFFMUIseURBQXlEO0lBQ3pELElBQUlDLFVBQVU7SUFDZCxJQUFLLElBQUlDLElBQUksR0FBR0EsSUFBSXBCLE1BQU1xQixNQUFNLEVBQUVELElBQUs7UUFDckMsSUFBSXBCLEtBQUssQ0FBQ29CLEVBQUUsR0FBR0QsU0FBU0EsVUFBVW5CLEtBQUssQ0FBQ29CLEVBQUU7SUFDNUM7SUFDQSxNQUFNRSxzQkFBc0IsWUFBYSxNQUFPSDtJQUVoRCw2REFBNkQ7SUFDN0QsTUFBTUksV0FBVy9CLEtBQUtFLEdBQUcsQ0FBQyxHQUFHRixLQUFLZ0MsS0FBSyxDQUFDLElBQUlSO0lBRTVDLGtEQUFrRDtJQUNsRCxJQUFLLElBQUl2QyxJQUFJOEMsVUFBVTlDLElBQUlTLFNBQVNxQyxVQUFVOUMsS0FBSzhDLFNBQVU7UUFDM0QsSUFBSyxJQUFJL0MsSUFBSStDLFVBQVUvQyxJQUFJRyxRQUFRNEMsVUFBVS9DLEtBQUsrQyxTQUFVO1lBQzFELE1BQU1FLFlBQVl6QixLQUFLLENBQUN2QixJQUFJRSxRQUFRSCxFQUFFO1lBRXRDLElBQUlpRCxZQUFZSCxxQkFBcUI7Z0JBQ25DLDBDQUEwQztnQkFDMUMsTUFBTUksV0FBV0QsWUFBWU47Z0JBRTdCLG1FQUFtRTtnQkFDbkUsTUFBTVEsZUFBZUosV0FBVyxNQUFPLEtBQUlHLFdBQVcsR0FBRTtnQkFDeEQsTUFBTUUsVUFBVSxDQUFDcEMsS0FBS3FDLE1BQU0sS0FBSyxHQUFFLElBQUtGO2dCQUN4QyxNQUFNRyxVQUFVLENBQUN0QyxLQUFLcUMsTUFBTSxLQUFLLEdBQUUsSUFBS0Y7Z0JBRXhDVCxPQUFPYSxJQUFJLENBQUM7b0JBQ1Z2RCxHQUFHQSxJQUFJb0Q7b0JBQ1BuRCxHQUFHQSxJQUFJcUQ7b0JBQ1BFLElBQUlkLE9BQU9HLE1BQU07Z0JBQ25CO2dCQUVBLGlFQUFpRTtnQkFDakUsSUFBSUssV0FBVyxPQUFPbEMsS0FBS3FDLE1BQU0sS0FBSyxLQUFLO29CQUN6QyxNQUFNSSxVQUFVLENBQUN6QyxLQUFLcUMsTUFBTSxLQUFLLEdBQUUsSUFBS047b0JBQ3hDLE1BQU1XLFVBQVUsQ0FBQzFDLEtBQUtxQyxNQUFNLEtBQUssR0FBRSxJQUFLTjtvQkFDeENMLE9BQU9hLElBQUksQ0FBQzt3QkFDVnZELEdBQUdBLElBQUl5RDt3QkFDUHhELEdBQUdBLElBQUl5RDt3QkFDUEYsSUFBSWQsT0FBT0csTUFBTTtvQkFDbkI7Z0JBQ0Y7WUFDRjtRQUNGO0lBQ0Y7SUFFQSwrREFBK0Q7SUFDL0QsTUFBTWMsV0FBVzNDLEtBQUtFLEdBQUcsQ0FBQyxJQUFJZixRQUFRO0lBQ3RDLElBQUssSUFBSUYsSUFBSTBELFVBQVUxRCxJQUFJUyxTQUFTaUQsVUFBVTFELEtBQUswRCxTQUFVO1FBQzNELElBQUssSUFBSTNELElBQUkyRCxVQUFVM0QsSUFBSUcsUUFBUXdELFVBQVUzRCxLQUFLMkQsU0FBVTtZQUMxRCxvREFBb0Q7WUFDcEQsTUFBTUMsWUFBWWxCLE9BQU9tQixJQUFJLENBQUNDLENBQUFBLElBQzVCOUMsS0FBSytDLEdBQUcsQ0FBQ0QsRUFBRTlELENBQUMsR0FBR0EsS0FBSzJELFdBQVcsT0FBTzNDLEtBQUsrQyxHQUFHLENBQUNELEVBQUU3RCxDQUFDLEdBQUdBLEtBQUswRCxXQUFXO1lBRXZFLElBQUksQ0FBQ0MsV0FBVztnQkFDZGxCLE9BQU9hLElBQUksQ0FBQztvQkFBRXZEO29CQUFHQztvQkFBR3VELElBQUlkLE9BQU9HLE1BQU07Z0JBQUM7WUFDeEM7UUFDRjtJQUNGO0lBRUEsK0NBQStDO0lBQy9DLE1BQU1tQixlQUFlaEQsS0FBS0UsR0FBRyxDQUFDLElBQUlmLFFBQVE7SUFDMUMsSUFBSyxJQUFJSCxJQUFJLEdBQUdBLEtBQUtHLE9BQU9ILEtBQUtnRSxhQUFjO1FBQzdDdEIsT0FBT2EsSUFBSSxDQUFDO1lBQUV2RDtZQUFHQyxHQUFHO1lBQUd1RCxJQUFJZCxPQUFPRyxNQUFNO1FBQUM7UUFDekNILE9BQU9hLElBQUksQ0FBQztZQUFFdkQ7WUFBR0MsR0FBR1M7WUFBUThDLElBQUlkLE9BQU9HLE1BQU07UUFBQztJQUNoRDtJQUNBLElBQUssSUFBSTVDLElBQUkrRCxjQUFjL0QsSUFBSVMsUUFBUVQsS0FBSytELGFBQWM7UUFDeER0QixPQUFPYSxJQUFJLENBQUM7WUFBRXZELEdBQUc7WUFBR0M7WUFBR3VELElBQUlkLE9BQU9HLE1BQU07UUFBQztRQUN6Q0gsT0FBT2EsSUFBSSxDQUFDO1lBQUV2RCxHQUFHRztZQUFPRjtZQUFHdUQsSUFBSWQsT0FBT0csTUFBTTtRQUFDO0lBQy9DO0lBRUEsb0JBQW9CO0lBQ3BCSCxPQUFPYSxJQUFJLENBQUM7UUFBRXZELEdBQUc7UUFBR0MsR0FBRztRQUFHdUQsSUFBSWQsT0FBT0csTUFBTTtJQUFDO0lBQzVDSCxPQUFPYSxJQUFJLENBQUM7UUFBRXZELEdBQUdHO1FBQU9GLEdBQUc7UUFBR3VELElBQUlkLE9BQU9HLE1BQU07SUFBQztJQUNoREgsT0FBT2EsSUFBSSxDQUFDO1FBQUV2RCxHQUFHO1FBQUdDLEdBQUdTO1FBQVE4QyxJQUFJZCxPQUFPRyxNQUFNO0lBQUM7SUFDakRILE9BQU9hLElBQUksQ0FBQztRQUFFdkQsR0FBR0c7UUFBT0YsR0FBR1M7UUFBUThDLElBQUlkLE9BQU9HLE1BQU07SUFBQztJQUVyRCxxREFBcUQ7SUFDckQsSUFBSUgsT0FBT0csTUFBTSxHQUFHSixXQUFXO1FBQzdCLHFGQUFxRjtRQUNyRixNQUFNd0IsaUJBQWlCdkIsT0FBT0csTUFBTSxHQUFHN0IsS0FBS2dDLEtBQUssQ0FBQzdDLFFBQVE2RCxnQkFBZ0IsSUFBSWhELEtBQUtnQyxLQUFLLENBQUN0QyxTQUFTc0QsZ0JBQWdCLElBQUk7UUFDdEgsTUFBTUUsaUJBQWlCeEIsT0FBT3lCLEtBQUssQ0FBQ0Y7UUFDcEMsTUFBTUcsYUFBYTFCLE9BQU95QixLQUFLLENBQUMsR0FBR0Y7UUFFbkMsb0NBQW9DO1FBQ3BDLE1BQU1JLGNBQWNELFdBQ2pCRSxJQUFJLENBQUMsSUFBTXRELEtBQUtxQyxNQUFNLEtBQUssS0FDM0JjLEtBQUssQ0FBQyxHQUFHMUIsWUFBWXlCLGVBQWVyQixNQUFNO1FBRTdDLE9BQU87ZUFBSXdCO2VBQWdCSDtTQUFlLENBQUNLLEdBQUcsQ0FBQyxDQUFDVCxHQUFHbEIsSUFBTztnQkFBRSxHQUFHa0IsQ0FBQztnQkFBRU4sSUFBSVo7WUFBRTtJQUMxRTtJQUVBLE9BQU9GO0FBQ1Q7QUFFQSx1REFBdUQ7QUFDdkQsU0FBUzhCLG9CQUFvQjlCLE1BQWUsRUFBRXZDLEtBQWEsRUFBRU8sTUFBYztJQUN6RSxJQUFJZ0MsT0FBT0csTUFBTSxHQUFHLEdBQUcsT0FBTyxFQUFFO0lBRWhDLGlEQUFpRDtJQUNqRCxNQUFNNEIsU0FBU3pELEtBQUtFLEdBQUcsQ0FBQ2YsT0FBT08sVUFBVTtJQUN6QyxNQUFNZ0UsY0FBdUI7UUFDM0I7WUFBRTFFLEdBQUdHLFFBQVE7WUFBR0YsR0FBRyxDQUFDd0U7WUFBUWpCLElBQUksQ0FBQztRQUFFO1FBQ25DO1lBQUV4RCxHQUFHLENBQUN5RTtZQUFReEUsR0FBR1MsU0FBUytEO1lBQVFqQixJQUFJLENBQUM7UUFBRTtRQUN6QztZQUFFeEQsR0FBR0csUUFBUXNFO1lBQVF4RSxHQUFHUyxTQUFTK0Q7WUFBUWpCLElBQUksQ0FBQztRQUFFO0tBQ2pEO0lBRUQsSUFBSW1CLFlBQXdCO1FBQUM7WUFDM0JDLElBQUlGLFdBQVcsQ0FBQyxFQUFFO1lBQ2xCRyxJQUFJSCxXQUFXLENBQUMsRUFBRTtZQUNsQkksSUFBSUosV0FBVyxDQUFDLEVBQUU7UUFDcEI7S0FBRTtJQUVGLDJCQUEyQjtJQUMzQixLQUFLLE1BQU1LLFNBQVNyQyxPQUFRO1FBQzFCLE1BQU1zQyxlQUEyQixFQUFFO1FBRW5DLDJEQUEyRDtRQUMzRCxLQUFLLE1BQU1DLFlBQVlOLFVBQVc7WUFDaEMsSUFBSU8sc0JBQXNCSCxPQUFPRSxXQUFXO2dCQUMxQ0QsYUFBYXpCLElBQUksQ0FBQzBCO1lBQ3BCO1FBQ0Y7UUFFQSw2Q0FBNkM7UUFDN0MsSUFBSUQsYUFBYW5DLE1BQU0sS0FBSyxHQUFHO1FBRS9CLDBDQUEwQztRQUMxQyxNQUFNc0MsVUFBMkMsRUFBRTtRQUVuRCxLQUFLLE1BQU1GLFlBQVlELGFBQWM7WUFDbkMsTUFBTXhELFFBQVE7Z0JBQ1o7b0JBQUVvRCxJQUFJSyxTQUFTTCxFQUFFO29CQUFFQyxJQUFJSSxTQUFTSixFQUFFO2dCQUFDO2dCQUNuQztvQkFBRUQsSUFBSUssU0FBU0osRUFBRTtvQkFBRUEsSUFBSUksU0FBU0gsRUFBRTtnQkFBQztnQkFDbkM7b0JBQUVGLElBQUlLLFNBQVNILEVBQUU7b0JBQUVELElBQUlJLFNBQVNMLEVBQUU7Z0JBQUM7YUFDcEM7WUFFRCxLQUFLLE1BQU1RLFFBQVE1RCxNQUFPO2dCQUN4QixvREFBb0Q7Z0JBQ3BELElBQUk2RCxXQUFXO2dCQUNmLEtBQUssTUFBTUMsU0FBU04sYUFBYztvQkFDaEMsSUFBSU0sVUFBVUwsVUFBVTtvQkFDeEIsSUFBSU0sUUFBUUQsT0FBT0YsT0FBTzt3QkFDeEJDLFdBQVc7d0JBQ1g7b0JBQ0Y7Z0JBQ0Y7Z0JBQ0EsSUFBSSxDQUFDQSxVQUFVO29CQUNiRixRQUFRNUIsSUFBSSxDQUFDNkI7Z0JBQ2Y7WUFDRjtRQUNGO1FBRUEsdUJBQXVCO1FBQ3ZCVCxZQUFZQSxVQUFVYSxNQUFNLENBQUMsQ0FBQ0MsSUFBTSxDQUFDVCxhQUFhVSxRQUFRLENBQUNEO1FBRTNELG1EQUFtRDtRQUNuRCxLQUFLLE1BQU1MLFFBQVFELFFBQVM7WUFDMUJSLFVBQVVwQixJQUFJLENBQUM7Z0JBQ2JxQixJQUFJUSxLQUFLUixFQUFFO2dCQUNYQyxJQUFJTyxLQUFLUCxFQUFFO2dCQUNYQyxJQUFJQztZQUNOO1FBQ0Y7SUFDRjtJQUVBLDJEQUEyRDtJQUMzREosWUFBWUEsVUFBVWEsTUFBTSxDQUMxQixDQUFDQyxJQUNDQSxFQUFFYixFQUFFLENBQUNwQixFQUFFLElBQUksS0FDWGlDLEVBQUVaLEVBQUUsQ0FBQ3JCLEVBQUUsSUFBSSxLQUNYaUMsRUFBRVgsRUFBRSxDQUFDdEIsRUFBRSxJQUFJO0lBR2YsT0FBT21CO0FBQ1Q7QUFFQSxzREFBc0Q7QUFDdEQsU0FBU08sc0JBQXNCSCxLQUFZLEVBQUVFLFFBQWtCO0lBQzdELE1BQU0sRUFBRUwsRUFBRSxFQUFFQyxFQUFFLEVBQUVDLEVBQUUsRUFBRSxHQUFHRztJQUV2Qiw2QkFBNkI7SUFDN0IsTUFBTVUsSUFBSSxJQUFLZixDQUFBQSxHQUFHNUUsQ0FBQyxHQUFJNkUsQ0FBQUEsR0FBRzVFLENBQUMsR0FBRzZFLEdBQUc3RSxDQUFDLElBQUk0RSxHQUFHN0UsQ0FBQyxHQUFJOEUsQ0FBQUEsR0FBRzdFLENBQUMsR0FBRzJFLEdBQUczRSxDQUFDLElBQUk2RSxHQUFHOUUsQ0FBQyxHQUFJNEUsQ0FBQUEsR0FBRzNFLENBQUMsR0FBRzRFLEdBQUc1RSxDQUFDO0lBRWhGLElBQUllLEtBQUsrQyxHQUFHLENBQUM0QixLQUFLLE9BQU8sT0FBTyxNQUFNLHNCQUFzQjs7SUFFNUQsTUFBTUMsS0FBSyxDQUFDLENBQUNoQixHQUFHNUUsQ0FBQyxHQUFHNEUsR0FBRzVFLENBQUMsR0FBRzRFLEdBQUczRSxDQUFDLEdBQUcyRSxHQUFHM0UsQ0FBQyxJQUFLNEUsQ0FBQUEsR0FBRzVFLENBQUMsR0FBRzZFLEdBQUc3RSxDQUFDLElBQzFDLENBQUM0RSxHQUFHN0UsQ0FBQyxHQUFHNkUsR0FBRzdFLENBQUMsR0FBRzZFLEdBQUc1RSxDQUFDLEdBQUc0RSxHQUFHNUUsQ0FBQyxJQUFLNkUsQ0FBQUEsR0FBRzdFLENBQUMsR0FBRzJFLEdBQUczRSxDQUFDLElBQzFDLENBQUM2RSxHQUFHOUUsQ0FBQyxHQUFHOEUsR0FBRzlFLENBQUMsR0FBRzhFLEdBQUc3RSxDQUFDLEdBQUc2RSxHQUFHN0UsQ0FBQyxJQUFLMkUsQ0FBQUEsR0FBRzNFLENBQUMsR0FBRzRFLEdBQUc1RSxDQUFDLEtBQUswRjtJQUMzRCxNQUFNRSxLQUFLLENBQUMsQ0FBQ2pCLEdBQUc1RSxDQUFDLEdBQUc0RSxHQUFHNUUsQ0FBQyxHQUFHNEUsR0FBRzNFLENBQUMsR0FBRzJFLEdBQUczRSxDQUFDLElBQUs2RSxDQUFBQSxHQUFHOUUsQ0FBQyxHQUFHNkUsR0FBRzdFLENBQUMsSUFDMUMsQ0FBQzZFLEdBQUc3RSxDQUFDLEdBQUc2RSxHQUFHN0UsQ0FBQyxHQUFHNkUsR0FBRzVFLENBQUMsR0FBRzRFLEdBQUc1RSxDQUFDLElBQUsyRSxDQUFBQSxHQUFHNUUsQ0FBQyxHQUFHOEUsR0FBRzlFLENBQUMsSUFDMUMsQ0FBQzhFLEdBQUc5RSxDQUFDLEdBQUc4RSxHQUFHOUUsQ0FBQyxHQUFHOEUsR0FBRzdFLENBQUMsR0FBRzZFLEdBQUc3RSxDQUFDLElBQUs0RSxDQUFBQSxHQUFHN0UsQ0FBQyxHQUFHNEUsR0FBRzVFLENBQUMsS0FBSzJGO0lBRTNELHVCQUF1QjtJQUN2QixNQUFNRyxXQUFXLENBQUNsQixHQUFHNUUsQ0FBQyxHQUFHNEYsRUFBQyxJQUFNaEIsQ0FBQUEsR0FBRzVFLENBQUMsR0FBRzRGLEVBQUMsSUFBSyxDQUFDaEIsR0FBRzNFLENBQUMsR0FBRzRGLEVBQUMsSUFBTWpCLENBQUFBLEdBQUczRSxDQUFDLEdBQUc0RixFQUFDO0lBRXBFLDhDQUE4QztJQUM5QyxNQUFNRSxTQUFTLENBQUNoQixNQUFNL0UsQ0FBQyxHQUFHNEYsRUFBQyxJQUFNYixDQUFBQSxNQUFNL0UsQ0FBQyxHQUFHNEYsRUFBQyxJQUFLLENBQUNiLE1BQU05RSxDQUFDLEdBQUc0RixFQUFDLElBQU1kLENBQUFBLE1BQU05RSxDQUFDLEdBQUc0RixFQUFDO0lBRTlFLE9BQU9FLFVBQVVEO0FBQ25CO0FBRUEsU0FBU1AsUUFBUU4sUUFBa0IsRUFBRUcsSUFBOEI7SUFDakUsTUFBTTFDLFNBQVM7UUFBQ3VDLFNBQVNMLEVBQUU7UUFBRUssU0FBU0osRUFBRTtRQUFFSSxTQUFTSCxFQUFFO0tBQUM7SUFDdEQsSUFBSWtCLFFBQVE7SUFDWixJQUFJQyxRQUFRO0lBRVosS0FBSyxNQUFNbkMsS0FBS3BCLE9BQVE7UUFDdEIsSUFBSW9CLEVBQUVOLEVBQUUsS0FBSzRCLEtBQUtSLEVBQUUsQ0FBQ3BCLEVBQUUsRUFBRXdDLFFBQVE7UUFDakMsSUFBSWxDLEVBQUVOLEVBQUUsS0FBSzRCLEtBQUtQLEVBQUUsQ0FBQ3JCLEVBQUUsRUFBRXlDLFFBQVE7SUFDbkM7SUFFQSxPQUFPRCxTQUFTQztBQUNsQjtBQUVPLFNBQVNDLGFBQWFDLE1BQXVCO0lBS2xELE1BQU0sRUFDSkMsUUFBUSxFQUNSakcsS0FBSyxFQUNMTyxNQUFNLEVBQ04yRixnQkFBZ0IsRUFBRSxFQUNsQkMsZUFBZSxJQUFJLEVBQ25CN0QsWUFBWSxHQUFHLEVBQ2hCLEdBQUcwRDtJQUVKLE1BQU0sQ0FBQ0ksTUFBTUMsUUFBUSxHQUFHL0csK0NBQVFBLENBQU87UUFBRWlELFFBQVEsRUFBRTtRQUFFaUMsV0FBVyxFQUFFO0lBQUM7SUFDbkUsTUFBTSxDQUFDOEIsV0FBV0MsYUFBYSxHQUFHakgsK0NBQVFBLENBQUM7SUFDM0MsTUFBTSxDQUFDa0gsT0FBT0MsU0FBUyxHQUFHbkgsK0NBQVFBLENBQWdCO0lBRWxEQyxnREFBU0EsQ0FBQztRQUNSLElBQUksQ0FBQzBHLFVBQVU7WUFDYk0sYUFBYTtZQUNiO1FBQ0Y7UUFFQSxNQUFNRyxlQUFlO1lBQ25CSCxhQUFhO1lBQ2JFLFNBQVM7WUFFVCxJQUFJO2dCQUNGLHVCQUF1QjtnQkFDdkIsTUFBTUUsTUFBTSxJQUFJQztnQkFDaEIseUNBQXlDO2dCQUN6QyxJQUFJWCxTQUFTWSxVQUFVLENBQUMsU0FBUztvQkFDL0JGLElBQUlHLFdBQVcsR0FBRztnQkFDcEI7Z0JBRUEsTUFBTSxJQUFJQyxRQUFjLENBQUNDLFNBQVNDO29CQUNoQ04sSUFBSU8sTUFBTSxHQUFHO3dCQUNYQyxRQUFRQyxHQUFHLENBQUMsOEJBQThCVCxJQUFJM0csS0FBSyxFQUFFMkcsSUFBSXBHLE1BQU07d0JBQy9EeUc7b0JBQ0Y7b0JBQ0FMLElBQUlVLE9BQU8sR0FBRyxDQUFDQzt3QkFDYkgsUUFBUVgsS0FBSyxDQUFDLHFCQUFxQmM7d0JBQ25DTCxPQUFPLElBQUlNLE1BQU07b0JBQ25CO29CQUNBWixJQUFJYSxHQUFHLEdBQUd2QjtnQkFDWjtnQkFFQSwrQkFBK0I7Z0JBQy9CLE1BQU13QixTQUFTQyxTQUFTQyxhQUFhLENBQUM7Z0JBQ3RDRixPQUFPekgsS0FBSyxHQUFHQTtnQkFDZnlILE9BQU9sSCxNQUFNLEdBQUdBO2dCQUNoQixNQUFNcUgsTUFBTUgsT0FBT0ksVUFBVSxDQUFDO2dCQUU5QixJQUFJLENBQUNELEtBQUs7b0JBQ1IsTUFBTSxJQUFJTCxNQUFNO2dCQUNsQjtnQkFFQSxtQ0FBbUM7Z0JBQ25DSyxJQUFJRSxTQUFTLENBQUNuQixLQUFLLEdBQUcsR0FBRzNHLE9BQU9PO2dCQUVoQyxpQkFBaUI7Z0JBQ2pCLE1BQU1YLFlBQVlnSSxJQUFJRyxZQUFZLENBQUMsR0FBRyxHQUFHL0gsT0FBT087Z0JBRWhELGVBQWU7Z0JBQ2YsTUFBTSxFQUFFYyxLQUFLLEVBQUUsR0FBR0gsWUFBWXRCO2dCQUM5QnVILFFBQVFDLEdBQUcsQ0FBQyw4QkFBOEJ2RyxLQUFLRSxHQUFHLElBQUlNO2dCQUV0RCw0QkFBNEI7Z0JBQzVCLE1BQU1rQixTQUFTSixpQkFDYmQsT0FDQXJCLE9BQ0FPLFFBQ0EyRixlQUNBQyxjQUNBN0Q7Z0JBRUY2RSxRQUFRQyxHQUFHLENBQUMsbUJBQW1CN0UsT0FBT0csTUFBTTtnQkFFNUMsZ0RBQWdEO2dCQUNoRCxNQUFNOEIsWUFBWUgsb0JBQW9COUIsUUFBUXZDLE9BQU9PO2dCQUNyRDRHLFFBQVFDLEdBQUcsQ0FBQyxzQkFBc0I1QyxVQUFVOUIsTUFBTTtnQkFFbEQyRCxRQUFRO29CQUFFOUQ7b0JBQVFpQztnQkFBVTtZQUM5QixFQUFFLE9BQU93RCxLQUFLO2dCQUNaYixRQUFRWCxLQUFLLENBQUMsdUJBQXVCd0I7Z0JBQ3JDdkIsU0FBU3VCLGVBQWVULFFBQVFTLElBQUlDLE9BQU8sR0FBRztnQkFDOUMseUJBQXlCO2dCQUN6QjVCLFFBQVE7b0JBQUU5RCxRQUFRLEVBQUU7b0JBQUVpQyxXQUFXLEVBQUU7Z0JBQUM7WUFDdEMsU0FBVTtnQkFDUitCLGFBQWE7WUFDZjtRQUNGO1FBRUFHO0lBQ0YsR0FBRztRQUFDVDtRQUFVakc7UUFBT087UUFBUTJGO1FBQWVDO1FBQWM3RDtLQUFVO0lBRXBFLE9BQU87UUFBRThEO1FBQU1FO1FBQVdFO0lBQU07QUFDbEMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vY29tcG9uZW50cy9wb3J0cmFpdC91c2VJbWFnZU1lc2gudHM/OTBkOSJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIGNsaWVudCdcblxuaW1wb3J0IHsgdXNlU3RhdGUsIHVzZUVmZmVjdCB9IGZyb20gJ3JlYWN0J1xuaW1wb3J0IHR5cGUgeyBNZXNoLCBQb2ludCwgVHJpYW5nbGUgfSBmcm9tICcuL3R5cGVzJ1xuXG5pbnRlcmZhY2UgSW1hZ2VNZXNoQ29uZmlnIHtcbiAgaW1hZ2VTcmM6IHN0cmluZ1xuICB3aWR0aDogbnVtYmVyXG4gIGhlaWdodDogbnVtYmVyXG4gIGVkZ2VUaHJlc2hvbGQ/OiBudW1iZXJcbiAgcG9pbnREZW5zaXR5PzogbnVtYmVyXG4gIG1heFBvaW50cz86IG51bWJlclxufVxuXG4vLyBTb2JlbCBlZGdlIGRldGVjdGlvbiBrZXJuZWxzXG5jb25zdCBTT0JFTF9YID0gW1xuICBbLTEsIDAsIDFdLFxuICBbLTIsIDAsIDJdLFxuICBbLTEsIDAsIDFdLFxuXVxuXG5jb25zdCBTT0JFTF9ZID0gW1xuICBbLTEsIC0yLCAtMV0sXG4gIFswLCAwLCAwXSxcbiAgWzEsIDIsIDFdLFxuXVxuXG4vLyBHYXVzc2lhbiBibHVyIGtlcm5lbCBmb3Igbm9pc2UgcmVkdWN0aW9uXG5jb25zdCBHQVVTU0lBTl8zeDMgPSBbXG4gIFsxLzE2LCAyLzE2LCAxLzE2XSxcbiAgWzIvMTYsIDQvMTYsIDIvMTZdLFxuICBbMS8xNiwgMi8xNiwgMS8xNl0sXG5dXG5cbmZ1bmN0aW9uIGdldFBpeGVsR3JheXNjYWxlKFxuICBpbWFnZURhdGE6IEltYWdlRGF0YSxcbiAgeDogbnVtYmVyLFxuICB5OiBudW1iZXJcbik6IG51bWJlciB7XG4gIGNvbnN0IGlkeCA9ICh5ICogaW1hZ2VEYXRhLndpZHRoICsgeCkgKiA0XG4gIGNvbnN0IHIgPSBpbWFnZURhdGEuZGF0YVtpZHhdXG4gIGNvbnN0IGcgPSBpbWFnZURhdGEuZGF0YVtpZHggKyAxXVxuICBjb25zdCBiID0gaW1hZ2VEYXRhLmRhdGFbaWR4ICsgMl1cbiAgLy8gTHVtaW5hbmNlIGZvcm11bGFcbiAgcmV0dXJuIDAuMjk5ICogciArIDAuNTg3ICogZyArIDAuMTE0ICogYlxufVxuXG5mdW5jdGlvbiBhcHBseUtlcm5lbChcbiAgZ3JheXNjYWxlOiBGbG9hdDMyQXJyYXksXG4gIHdpZHRoOiBudW1iZXIsXG4gIGhlaWdodDogbnVtYmVyLFxuICB4OiBudW1iZXIsXG4gIHk6IG51bWJlcixcbiAga2VybmVsOiBudW1iZXJbXVtdXG4pOiBudW1iZXIge1xuICBsZXQgc3VtID0gMFxuICBmb3IgKGxldCBreSA9IC0xOyBreSA8PSAxOyBreSsrKSB7XG4gICAgZm9yIChsZXQga3ggPSAtMTsga3ggPD0gMTsga3grKykge1xuICAgICAgY29uc3QgcHggPSBNYXRoLm1pbihNYXRoLm1heCh4ICsga3gsIDApLCB3aWR0aCAtIDEpXG4gICAgICBjb25zdCBweSA9IE1hdGgubWluKE1hdGgubWF4KHkgKyBreSwgMCksIGhlaWdodCAtIDEpXG4gICAgICBjb25zdCBncmF5ID0gZ3JheXNjYWxlW3B5ICogd2lkdGggKyBweF1cbiAgICAgIHN1bSArPSBncmF5ICoga2VybmVsW2t5ICsgMV1ba3ggKyAxXVxuICAgIH1cbiAgfVxuICByZXR1cm4gc3VtXG59XG5cbmZ1bmN0aW9uIGRldGVjdEVkZ2VzKGltYWdlRGF0YTogSW1hZ2VEYXRhKTogeyBlZGdlczogRmxvYXQzMkFycmF5OyBkaXJlY3Rpb25zOiBGbG9hdDMyQXJyYXkgfSB7XG4gIGNvbnN0IHdpZHRoID0gaW1hZ2VEYXRhLndpZHRoXG4gIGNvbnN0IGhlaWdodCA9IGltYWdlRGF0YS5oZWlnaHRcbiAgXG4gIC8vIENvbnZlcnQgdG8gZ3JheXNjYWxlXG4gIGNvbnN0IGdyYXlzY2FsZSA9IG5ldyBGbG9hdDMyQXJyYXkod2lkdGggKiBoZWlnaHQpXG4gIGZvciAobGV0IHkgPSAwOyB5IDwgaGVpZ2h0OyB5KyspIHtcbiAgICBmb3IgKGxldCB4ID0gMDsgeCA8IHdpZHRoOyB4KyspIHtcbiAgICAgIGdyYXlzY2FsZVt5ICogd2lkdGggKyB4XSA9IGdldFBpeGVsR3JheXNjYWxlKGltYWdlRGF0YSwgeCwgeSlcbiAgICB9XG4gIH1cbiAgXG4gIC8vIEFwcGx5IEdhdXNzaWFuIGJsdXIgdG8gcmVkdWNlIG5vaXNlXG4gIGNvbnN0IGJsdXJyZWQgPSBuZXcgRmxvYXQzMkFycmF5KHdpZHRoICogaGVpZ2h0KVxuICBmb3IgKGxldCB5ID0gMTsgeSA8IGhlaWdodCAtIDE7IHkrKykge1xuICAgIGZvciAobGV0IHggPSAxOyB4IDwgd2lkdGggLSAxOyB4KyspIHtcbiAgICAgIGJsdXJyZWRbeSAqIHdpZHRoICsgeF0gPSBhcHBseUtlcm5lbChncmF5c2NhbGUsIHdpZHRoLCBoZWlnaHQsIHgsIHksIEdBVVNTSUFOXzN4MylcbiAgICB9XG4gIH1cbiAgXG4gIC8vIEFwcGx5IFNvYmVsIG9wZXJhdG9yXG4gIGNvbnN0IGVkZ2VzID0gbmV3IEZsb2F0MzJBcnJheSh3aWR0aCAqIGhlaWdodClcbiAgY29uc3QgZGlyZWN0aW9ucyA9IG5ldyBGbG9hdDMyQXJyYXkod2lkdGggKiBoZWlnaHQpXG4gIFxuICBmb3IgKGxldCB5ID0gMTsgeSA8IGhlaWdodCAtIDE7IHkrKykge1xuICAgIGZvciAobGV0IHggPSAxOyB4IDwgd2lkdGggLSAxOyB4KyspIHtcbiAgICAgIGNvbnN0IGd4ID0gYXBwbHlLZXJuZWwoYmx1cnJlZCwgd2lkdGgsIGhlaWdodCwgeCwgeSwgU09CRUxfWClcbiAgICAgIGNvbnN0IGd5ID0gYXBwbHlLZXJuZWwoYmx1cnJlZCwgd2lkdGgsIGhlaWdodCwgeCwgeSwgU09CRUxfWSlcbiAgICAgIGNvbnN0IG1hZ25pdHVkZSA9IE1hdGguc3FydChneCAqIGd4ICsgZ3kgKiBneSlcbiAgICAgIGVkZ2VzW3kgKiB3aWR0aCArIHhdID0gbWFnbml0dWRlXG4gICAgICBkaXJlY3Rpb25zW3kgKiB3aWR0aCArIHhdID0gTWF0aC5hdGFuMihneSwgZ3gpXG4gICAgfVxuICB9XG4gIFxuICAvLyBOb24tbWF4aW11bSBzdXBwcmVzc2lvbiBmb3IgdGhpbm5lciBlZGdlc1xuICBjb25zdCBzdXBwcmVzc2VkID0gbmV3IEZsb2F0MzJBcnJheSh3aWR0aCAqIGhlaWdodClcbiAgZm9yIChsZXQgeSA9IDI7IHkgPCBoZWlnaHQgLSAyOyB5KyspIHtcbiAgICBmb3IgKGxldCB4ID0gMjsgeCA8IHdpZHRoIC0gMjsgeCsrKSB7XG4gICAgICBjb25zdCBhbmdsZSA9IGRpcmVjdGlvbnNbeSAqIHdpZHRoICsgeF1cbiAgICAgIGNvbnN0IG1hZyA9IGVkZ2VzW3kgKiB3aWR0aCArIHhdXG4gICAgICBcbiAgICAgIC8vIEdldCBuZWlnaGJvcnMgaW4gZ3JhZGllbnQgZGlyZWN0aW9uXG4gICAgICBsZXQgbmVpZ2hib3IxID0gMCwgbmVpZ2hib3IyID0gMFxuICAgICAgY29uc3Qgbm9ybWFsaXplZEFuZ2xlID0gKChhbmdsZSArIE1hdGguUEkpIC8gTWF0aC5QSSkgKiA0ICUgNFxuICAgICAgXG4gICAgICBpZiAobm9ybWFsaXplZEFuZ2xlIDwgMSB8fCBub3JtYWxpemVkQW5nbGUgPj0gMykge1xuICAgICAgICAvLyBIb3Jpem9udGFsXG4gICAgICAgIG5laWdoYm9yMSA9IGVkZ2VzW3kgKiB3aWR0aCArICh4IC0gMSldXG4gICAgICAgIG5laWdoYm9yMiA9IGVkZ2VzW3kgKiB3aWR0aCArICh4ICsgMSldXG4gICAgICB9IGVsc2UgaWYgKG5vcm1hbGl6ZWRBbmdsZSA+PSAxICYmIG5vcm1hbGl6ZWRBbmdsZSA8IDIpIHtcbiAgICAgICAgLy8gRGlhZ29uYWwgL1xuICAgICAgICBuZWlnaGJvcjEgPSBlZGdlc1soeSAtIDEpICogd2lkdGggKyAoeCArIDEpXVxuICAgICAgICBuZWlnaGJvcjIgPSBlZGdlc1soeSArIDEpICogd2lkdGggKyAoeCAtIDEpXVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gRGlhZ29uYWwgXFxcbiAgICAgICAgbmVpZ2hib3IxID0gZWRnZXNbKHkgLSAxKSAqIHdpZHRoICsgKHggLSAxKV1cbiAgICAgICAgbmVpZ2hib3IyID0gZWRnZXNbKHkgKyAxKSAqIHdpZHRoICsgKHggKyAxKV1cbiAgICAgIH1cbiAgICAgIFxuICAgICAgLy8gS2VlcCBvbmx5IGxvY2FsIG1heGltYVxuICAgICAgaWYgKG1hZyA+PSBuZWlnaGJvcjEgJiYgbWFnID49IG5laWdoYm9yMikge1xuICAgICAgICBzdXBwcmVzc2VkW3kgKiB3aWR0aCArIHhdID0gbWFnXG4gICAgICB9XG4gICAgfVxuICB9XG4gIFxuICByZXR1cm4geyBlZGdlczogc3VwcHJlc3NlZCwgZGlyZWN0aW9ucyB9XG59XG5cbmZ1bmN0aW9uIHNhbXBsZUVkZ2VQb2ludHMoXG4gIGVkZ2VzOiBGbG9hdDMyQXJyYXksXG4gIHdpZHRoOiBudW1iZXIsXG4gIGhlaWdodDogbnVtYmVyLFxuICB0aHJlc2hvbGQ6IG51bWJlcixcbiAgZGVuc2l0eTogbnVtYmVyLFxuICBtYXhQb2ludHM6IG51bWJlclxuKTogUG9pbnRbXSB7XG4gIGNvbnN0IHBvaW50czogUG9pbnRbXSA9IFtdXG4gIFxuICAvLyBOb3JtYWxpemUgZWRnZXMgdG8gMC0yNTUgcmFuZ2UgZm9yIGJldHRlciB0aHJlc2hvbGRpbmdcbiAgbGV0IG1heEVkZ2UgPSAwXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgZWRnZXMubGVuZ3RoOyBpKyspIHtcbiAgICBpZiAoZWRnZXNbaV0gPiBtYXhFZGdlKSBtYXhFZGdlID0gZWRnZXNbaV1cbiAgfVxuICBjb25zdCBub3JtYWxpemVkVGhyZXNob2xkID0gKHRocmVzaG9sZCAvIDI1NSkgKiBtYXhFZGdlXG4gIFxuICAvLyBBZGFwdGl2ZSBzYW1wbGluZyAtIHNtYWxsZXIgc3RlcCBmb3IgZGVuc2VyIHBvaW50IGNvdmVyYWdlXG4gIGNvbnN0IGJhc2VTdGVwID0gTWF0aC5tYXgoMiwgTWF0aC5mbG9vcigxIC8gZGVuc2l0eSkpXG4gIFxuICAvLyBTYW1wbGUgcG9pbnRzIGFsb25nIGVkZ2VzIHdpdGggYWRhcHRpdmUgZGVuc2l0eVxuICBmb3IgKGxldCB5ID0gYmFzZVN0ZXA7IHkgPCBoZWlnaHQgLSBiYXNlU3RlcDsgeSArPSBiYXNlU3RlcCkge1xuICAgIGZvciAobGV0IHggPSBiYXNlU3RlcDsgeCA8IHdpZHRoIC0gYmFzZVN0ZXA7IHggKz0gYmFzZVN0ZXApIHtcbiAgICAgIGNvbnN0IGVkZ2VWYWx1ZSA9IGVkZ2VzW3kgKiB3aWR0aCArIHhdXG4gICAgICBcbiAgICAgIGlmIChlZGdlVmFsdWUgPiBub3JtYWxpemVkVGhyZXNob2xkKSB7XG4gICAgICAgIC8vIFN0cm9uZ2VyIGVkZ2VzIGdldCBwb2ludHMgbW9yZSByZWxpYWJseVxuICAgICAgICBjb25zdCBzdHJlbmd0aCA9IGVkZ2VWYWx1ZSAvIG1heEVkZ2VcbiAgICAgICAgXG4gICAgICAgIC8vIEFkZCBzbGlnaHQgaml0dGVyIGZvciBvcmdhbmljIGxvb2ssIGxlc3Mgaml0dGVyIGZvciBzdHJvbmcgZWRnZXNcbiAgICAgICAgY29uc3Qgaml0dGVyQW1vdW50ID0gYmFzZVN0ZXAgKiAwLjMgKiAoMSAtIHN0cmVuZ3RoICogMC41KVxuICAgICAgICBjb25zdCBqaXR0ZXJYID0gKE1hdGgucmFuZG9tKCkgLSAwLjUpICogaml0dGVyQW1vdW50XG4gICAgICAgIGNvbnN0IGppdHRlclkgPSAoTWF0aC5yYW5kb20oKSAtIDAuNSkgKiBqaXR0ZXJBbW91bnRcbiAgICAgICAgXG4gICAgICAgIHBvaW50cy5wdXNoKHtcbiAgICAgICAgICB4OiB4ICsgaml0dGVyWCxcbiAgICAgICAgICB5OiB5ICsgaml0dGVyWSxcbiAgICAgICAgICBpZDogcG9pbnRzLmxlbmd0aCxcbiAgICAgICAgfSlcbiAgICAgICAgXG4gICAgICAgIC8vIEZvciB2ZXJ5IHN0cm9uZyBlZGdlcywgYWRkIGFkZGl0aW9uYWwgbmVhcmJ5IHBvaW50cyBmb3IgZGV0YWlsXG4gICAgICAgIGlmIChzdHJlbmd0aCA+IDAuNiAmJiBNYXRoLnJhbmRvbSgpID4gMC41KSB7XG4gICAgICAgICAgY29uc3Qgb2Zmc2V0WCA9IChNYXRoLnJhbmRvbSgpIC0gMC41KSAqIGJhc2VTdGVwXG4gICAgICAgICAgY29uc3Qgb2Zmc2V0WSA9IChNYXRoLnJhbmRvbSgpIC0gMC41KSAqIGJhc2VTdGVwXG4gICAgICAgICAgcG9pbnRzLnB1c2goe1xuICAgICAgICAgICAgeDogeCArIG9mZnNldFgsXG4gICAgICAgICAgICB5OiB5ICsgb2Zmc2V0WSxcbiAgICAgICAgICAgIGlkOiBwb2ludHMubGVuZ3RoLFxuICAgICAgICAgIH0pXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgXG4gIC8vIEFkZCBncmlkIHBvaW50cyBmb3IgYmV0dGVyIGNvdmVyYWdlIChzcGFyc2UgYmFja2dyb3VuZCBtZXNoKVxuICBjb25zdCBncmlkU3RlcCA9IE1hdGgubWF4KDI1LCB3aWR0aCAvIDEyKVxuICBmb3IgKGxldCB5ID0gZ3JpZFN0ZXA7IHkgPCBoZWlnaHQgLSBncmlkU3RlcDsgeSArPSBncmlkU3RlcCkge1xuICAgIGZvciAobGV0IHggPSBncmlkU3RlcDsgeCA8IHdpZHRoIC0gZ3JpZFN0ZXA7IHggKz0gZ3JpZFN0ZXApIHtcbiAgICAgIC8vIE9ubHkgYWRkIGlmIG5vdCB0b28gY2xvc2UgdG8gZXhpc3RpbmcgZWRnZSBwb2ludHNcbiAgICAgIGNvbnN0IGhhc05lYXJieSA9IHBvaW50cy5zb21lKHAgPT4gXG4gICAgICAgIE1hdGguYWJzKHAueCAtIHgpIDwgZ3JpZFN0ZXAgKiAwLjQgJiYgTWF0aC5hYnMocC55IC0geSkgPCBncmlkU3RlcCAqIDAuNFxuICAgICAgKVxuICAgICAgaWYgKCFoYXNOZWFyYnkpIHtcbiAgICAgICAgcG9pbnRzLnB1c2goeyB4LCB5LCBpZDogcG9pbnRzLmxlbmd0aCB9KVxuICAgICAgfVxuICAgIH1cbiAgfVxuICBcbiAgLy8gQWRkIGJvdW5kYXJ5IHBvaW50cyBmb3IgYmV0dGVyIHRyaWFuZ3VsYXRpb25cbiAgY29uc3QgYm91bmRhcnlTdGVwID0gTWF0aC5tYXgoMTUsIHdpZHRoIC8gMjApXG4gIGZvciAobGV0IHggPSAwOyB4IDw9IHdpZHRoOyB4ICs9IGJvdW5kYXJ5U3RlcCkge1xuICAgIHBvaW50cy5wdXNoKHsgeCwgeTogMCwgaWQ6IHBvaW50cy5sZW5ndGggfSlcbiAgICBwb2ludHMucHVzaCh7IHgsIHk6IGhlaWdodCwgaWQ6IHBvaW50cy5sZW5ndGggfSlcbiAgfVxuICBmb3IgKGxldCB5ID0gYm91bmRhcnlTdGVwOyB5IDwgaGVpZ2h0OyB5ICs9IGJvdW5kYXJ5U3RlcCkge1xuICAgIHBvaW50cy5wdXNoKHsgeDogMCwgeSwgaWQ6IHBvaW50cy5sZW5ndGggfSlcbiAgICBwb2ludHMucHVzaCh7IHg6IHdpZHRoLCB5LCBpZDogcG9pbnRzLmxlbmd0aCB9KVxuICB9XG4gIFxuICAvLyBBZGQgY29ybmVyIHBvaW50c1xuICBwb2ludHMucHVzaCh7IHg6IDAsIHk6IDAsIGlkOiBwb2ludHMubGVuZ3RoIH0pXG4gIHBvaW50cy5wdXNoKHsgeDogd2lkdGgsIHk6IDAsIGlkOiBwb2ludHMubGVuZ3RoIH0pXG4gIHBvaW50cy5wdXNoKHsgeDogMCwgeTogaGVpZ2h0LCBpZDogcG9pbnRzLmxlbmd0aCB9KVxuICBwb2ludHMucHVzaCh7IHg6IHdpZHRoLCB5OiBoZWlnaHQsIGlkOiBwb2ludHMubGVuZ3RoIH0pXG4gIFxuICAvLyBMaW1pdCBwb2ludHMgaWYgdG9vIG1hbnksIHByaW9yaXRpemluZyBlZGdlIHBvaW50c1xuICBpZiAocG9pbnRzLmxlbmd0aCA+IG1heFBvaW50cykge1xuICAgIC8vIFNvcnQgYnkgaG93IGNsb3NlIHRoZXkgYXJlIHRvIHN0cm9uZyBlZGdlcyAoYXBwcm94aW1hdGUgYnkga2VlcGluZyBlYXJsaWVyIHBvaW50cylcbiAgICBjb25zdCBlZGdlUG9pbnRDb3VudCA9IHBvaW50cy5sZW5ndGggLSBNYXRoLmZsb29yKHdpZHRoIC8gYm91bmRhcnlTdGVwKSAqIDIgLSBNYXRoLmZsb29yKGhlaWdodCAvIGJvdW5kYXJ5U3RlcCkgKiAyIC0gNFxuICAgIGNvbnN0IGJvdW5kYXJ5UG9pbnRzID0gcG9pbnRzLnNsaWNlKGVkZ2VQb2ludENvdW50KVxuICAgIGNvbnN0IGVkZ2VQb2ludHMgPSBwb2ludHMuc2xpY2UoMCwgZWRnZVBvaW50Q291bnQpXG4gICAgXG4gICAgLy8gS2VlcCBhIGdvb2Qgc2FtcGxlIG9mIGVkZ2UgcG9pbnRzXG4gICAgY29uc3Qgc2FtcGxlZEVkZ2UgPSBlZGdlUG9pbnRzXG4gICAgICAuc29ydCgoKSA9PiBNYXRoLnJhbmRvbSgpIC0gMC41KVxuICAgICAgLnNsaWNlKDAsIG1heFBvaW50cyAtIGJvdW5kYXJ5UG9pbnRzLmxlbmd0aClcbiAgICBcbiAgICByZXR1cm4gWy4uLnNhbXBsZWRFZGdlLCAuLi5ib3VuZGFyeVBvaW50c10ubWFwKChwLCBpKSA9PiAoeyAuLi5wLCBpZDogaSB9KSlcbiAgfVxuICBcbiAgcmV0dXJuIHBvaW50c1xufVxuXG4vLyBEZWxhdW5heSB0cmlhbmd1bGF0aW9uIHVzaW5nIEJvd3llci1XYXRzb24gYWxnb3JpdGhtXG5mdW5jdGlvbiBkZWxhdW5heVRyaWFuZ3VsYXRlKHBvaW50czogUG9pbnRbXSwgd2lkdGg6IG51bWJlciwgaGVpZ2h0OiBudW1iZXIpOiBUcmlhbmdsZVtdIHtcbiAgaWYgKHBvaW50cy5sZW5ndGggPCAzKSByZXR1cm4gW11cbiAgXG4gIC8vIENyZWF0ZSBzdXBlciB0cmlhbmdsZSB0aGF0IGNvbnRhaW5zIGFsbCBwb2ludHNcbiAgY29uc3QgbWFyZ2luID0gTWF0aC5tYXgod2lkdGgsIGhlaWdodCkgKiAzXG4gIGNvbnN0IHN1cGVyUG9pbnRzOiBQb2ludFtdID0gW1xuICAgIHsgeDogd2lkdGggLyAyLCB5OiAtbWFyZ2luLCBpZDogLTEgfSxcbiAgICB7IHg6IC1tYXJnaW4sIHk6IGhlaWdodCArIG1hcmdpbiwgaWQ6IC0yIH0sXG4gICAgeyB4OiB3aWR0aCArIG1hcmdpbiwgeTogaGVpZ2h0ICsgbWFyZ2luLCBpZDogLTMgfSxcbiAgXVxuICBcbiAgbGV0IHRyaWFuZ2xlczogVHJpYW5nbGVbXSA9IFt7XG4gICAgcDE6IHN1cGVyUG9pbnRzWzBdLFxuICAgIHAyOiBzdXBlclBvaW50c1sxXSxcbiAgICBwMzogc3VwZXJQb2ludHNbMl0sXG4gIH1dXG4gIFxuICAvLyBBZGQgcG9pbnRzIG9uZSBhdCBhIHRpbWVcbiAgZm9yIChjb25zdCBwb2ludCBvZiBwb2ludHMpIHtcbiAgICBjb25zdCBiYWRUcmlhbmdsZXM6IFRyaWFuZ2xlW10gPSBbXVxuICAgIFxuICAgIC8vIEZpbmQgYWxsIHRyaWFuZ2xlcyB3aG9zZSBjaXJjdW1jaXJjbGUgY29udGFpbnMgdGhlIHBvaW50XG4gICAgZm9yIChjb25zdCB0cmlhbmdsZSBvZiB0cmlhbmdsZXMpIHtcbiAgICAgIGlmIChpc1BvaW50SW5DaXJjdW1jaXJjbGUocG9pbnQsIHRyaWFuZ2xlKSkge1xuICAgICAgICBiYWRUcmlhbmdsZXMucHVzaCh0cmlhbmdsZSlcbiAgICAgIH1cbiAgICB9XG4gICAgXG4gICAgLy8gSWYgbm8gYmFkIHRyaWFuZ2xlcyBmb3VuZCwgc2tpcCB0aGlzIHBvaW50XG4gICAgaWYgKGJhZFRyaWFuZ2xlcy5sZW5ndGggPT09IDApIGNvbnRpbnVlXG4gICAgXG4gICAgLy8gRmluZCB0aGUgYm91bmRhcnkgb2YgdGhlIHBvbHlnb25hbCBob2xlXG4gICAgY29uc3QgcG9seWdvbjogQXJyYXk8eyBwMTogUG9pbnQ7IHAyOiBQb2ludCB9PiA9IFtdXG4gICAgXG4gICAgZm9yIChjb25zdCB0cmlhbmdsZSBvZiBiYWRUcmlhbmdsZXMpIHtcbiAgICAgIGNvbnN0IGVkZ2VzID0gW1xuICAgICAgICB7IHAxOiB0cmlhbmdsZS5wMSwgcDI6IHRyaWFuZ2xlLnAyIH0sXG4gICAgICAgIHsgcDE6IHRyaWFuZ2xlLnAyLCBwMjogdHJpYW5nbGUucDMgfSxcbiAgICAgICAgeyBwMTogdHJpYW5nbGUucDMsIHAyOiB0cmlhbmdsZS5wMSB9LFxuICAgICAgXVxuICAgICAgXG4gICAgICBmb3IgKGNvbnN0IGVkZ2Ugb2YgZWRnZXMpIHtcbiAgICAgICAgLy8gQ2hlY2sgaWYgZWRnZSBpcyBzaGFyZWQgd2l0aCBhbm90aGVyIGJhZCB0cmlhbmdsZVxuICAgICAgICBsZXQgaXNTaGFyZWQgPSBmYWxzZVxuICAgICAgICBmb3IgKGNvbnN0IG90aGVyIG9mIGJhZFRyaWFuZ2xlcykge1xuICAgICAgICAgIGlmIChvdGhlciA9PT0gdHJpYW5nbGUpIGNvbnRpbnVlXG4gICAgICAgICAgaWYgKGhhc0VkZ2Uob3RoZXIsIGVkZ2UpKSB7XG4gICAgICAgICAgICBpc1NoYXJlZCA9IHRydWVcbiAgICAgICAgICAgIGJyZWFrXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICghaXNTaGFyZWQpIHtcbiAgICAgICAgICBwb2x5Z29uLnB1c2goZWRnZSlcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBcbiAgICAvLyBSZW1vdmUgYmFkIHRyaWFuZ2xlc1xuICAgIHRyaWFuZ2xlcyA9IHRyaWFuZ2xlcy5maWx0ZXIoKHQpID0+ICFiYWRUcmlhbmdsZXMuaW5jbHVkZXModCkpXG4gICAgXG4gICAgLy8gQ3JlYXRlIG5ldyB0cmlhbmdsZXMgZnJvbSBwb2x5Z29uIGVkZ2VzIHRvIHBvaW50XG4gICAgZm9yIChjb25zdCBlZGdlIG9mIHBvbHlnb24pIHtcbiAgICAgIHRyaWFuZ2xlcy5wdXNoKHtcbiAgICAgICAgcDE6IGVkZ2UucDEsXG4gICAgICAgIHAyOiBlZGdlLnAyLFxuICAgICAgICBwMzogcG9pbnQsXG4gICAgICB9KVxuICAgIH1cbiAgfVxuICBcbiAgLy8gUmVtb3ZlIHRyaWFuZ2xlcyB0aGF0IHNoYXJlIHZlcnRpY2VzIHdpdGggc3VwZXIgdHJpYW5nbGVcbiAgdHJpYW5nbGVzID0gdHJpYW5nbGVzLmZpbHRlcihcbiAgICAodCkgPT5cbiAgICAgIHQucDEuaWQgPj0gMCAmJlxuICAgICAgdC5wMi5pZCA+PSAwICYmXG4gICAgICB0LnAzLmlkID49IDBcbiAgKVxuICBcbiAgcmV0dXJuIHRyaWFuZ2xlc1xufVxuXG4vLyBDYWxjdWxhdGUgY2lyY3VtY2lyY2xlIGFuZCBjaGVjayBpZiBwb2ludCBpcyBpbnNpZGVcbmZ1bmN0aW9uIGlzUG9pbnRJbkNpcmN1bWNpcmNsZShwb2ludDogUG9pbnQsIHRyaWFuZ2xlOiBUcmlhbmdsZSk6IGJvb2xlYW4ge1xuICBjb25zdCB7IHAxLCBwMiwgcDMgfSA9IHRyaWFuZ2xlXG4gIFxuICAvLyBDYWxjdWxhdGUgdGhlIGNpcmN1bWNlbnRlclxuICBjb25zdCBkID0gMiAqIChwMS54ICogKHAyLnkgLSBwMy55KSArIHAyLnggKiAocDMueSAtIHAxLnkpICsgcDMueCAqIChwMS55IC0gcDIueSkpXG4gIFxuICBpZiAoTWF0aC5hYnMoZCkgPCAxZS0xMCkgcmV0dXJuIGZhbHNlIC8vIERlZ2VuZXJhdGUgdHJpYW5nbGVcbiAgXG4gIGNvbnN0IHV4ID0gKChwMS54ICogcDEueCArIHAxLnkgKiBwMS55KSAqIChwMi55IC0gcDMueSkgKyBcbiAgICAgICAgICAgICAgKHAyLnggKiBwMi54ICsgcDIueSAqIHAyLnkpICogKHAzLnkgLSBwMS55KSArIFxuICAgICAgICAgICAgICAocDMueCAqIHAzLnggKyBwMy55ICogcDMueSkgKiAocDEueSAtIHAyLnkpKSAvIGRcbiAgY29uc3QgdXkgPSAoKHAxLnggKiBwMS54ICsgcDEueSAqIHAxLnkpICogKHAzLnggLSBwMi54KSArIFxuICAgICAgICAgICAgICAocDIueCAqIHAyLnggKyBwMi55ICogcDIueSkgKiAocDEueCAtIHAzLngpICsgXG4gICAgICAgICAgICAgIChwMy54ICogcDMueCArIHAzLnkgKiBwMy55KSAqIChwMi54IC0gcDEueCkpIC8gZFxuICBcbiAgLy8gQ2lyY3VtcmFkaXVzIHNxdWFyZWRcbiAgY29uc3QgcmFkaXVzU3EgPSAocDEueCAtIHV4KSAqIChwMS54IC0gdXgpICsgKHAxLnkgLSB1eSkgKiAocDEueSAtIHV5KVxuICBcbiAgLy8gRGlzdGFuY2UgZnJvbSBwb2ludCB0byBjaXJjdW1jZW50ZXIgc3F1YXJlZFxuICBjb25zdCBkaXN0U3EgPSAocG9pbnQueCAtIHV4KSAqIChwb2ludC54IC0gdXgpICsgKHBvaW50LnkgLSB1eSkgKiAocG9pbnQueSAtIHV5KVxuICBcbiAgcmV0dXJuIGRpc3RTcSA8PSByYWRpdXNTcVxufVxuXG5mdW5jdGlvbiBoYXNFZGdlKHRyaWFuZ2xlOiBUcmlhbmdsZSwgZWRnZTogeyBwMTogUG9pbnQ7IHAyOiBQb2ludCB9KTogYm9vbGVhbiB7XG4gIGNvbnN0IHBvaW50cyA9IFt0cmlhbmdsZS5wMSwgdHJpYW5nbGUucDIsIHRyaWFuZ2xlLnAzXVxuICBsZXQgaGFzUDEgPSBmYWxzZVxuICBsZXQgaGFzUDIgPSBmYWxzZVxuICBcbiAgZm9yIChjb25zdCBwIG9mIHBvaW50cykge1xuICAgIGlmIChwLmlkID09PSBlZGdlLnAxLmlkKSBoYXNQMSA9IHRydWVcbiAgICBpZiAocC5pZCA9PT0gZWRnZS5wMi5pZCkgaGFzUDIgPSB0cnVlXG4gIH1cbiAgXG4gIHJldHVybiBoYXNQMSAmJiBoYXNQMlxufVxuXG5leHBvcnQgZnVuY3Rpb24gdXNlSW1hZ2VNZXNoKGNvbmZpZzogSW1hZ2VNZXNoQ29uZmlnKToge1xuICBtZXNoOiBNZXNoXG4gIGlzTG9hZGluZzogYm9vbGVhblxuICBlcnJvcjogc3RyaW5nIHwgbnVsbFxufSB7XG4gIGNvbnN0IHtcbiAgICBpbWFnZVNyYyxcbiAgICB3aWR0aCxcbiAgICBoZWlnaHQsXG4gICAgZWRnZVRocmVzaG9sZCA9IDUwLFxuICAgIHBvaW50RGVuc2l0eSA9IDAuMDgsXG4gICAgbWF4UG9pbnRzID0gNTAwLFxuICB9ID0gY29uZmlnXG5cbiAgY29uc3QgW21lc2gsIHNldE1lc2hdID0gdXNlU3RhdGU8TWVzaD4oeyBwb2ludHM6IFtdLCB0cmlhbmdsZXM6IFtdIH0pXG4gIGNvbnN0IFtpc0xvYWRpbmcsIHNldElzTG9hZGluZ10gPSB1c2VTdGF0ZSh0cnVlKVxuICBjb25zdCBbZXJyb3IsIHNldEVycm9yXSA9IHVzZVN0YXRlPHN0cmluZyB8IG51bGw+KG51bGwpXG5cbiAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICBpZiAoIWltYWdlU3JjKSB7XG4gICAgICBzZXRJc0xvYWRpbmcoZmFsc2UpXG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICBjb25zdCBwcm9jZXNzSW1hZ2UgPSBhc3luYyAoKSA9PiB7XG4gICAgICBzZXRJc0xvYWRpbmcodHJ1ZSlcbiAgICAgIHNldEVycm9yKG51bGwpXG5cbiAgICAgIHRyeSB7XG4gICAgICAgIC8vIENyZWF0ZSBpbWFnZSBlbGVtZW50XG4gICAgICAgIGNvbnN0IGltZyA9IG5ldyBJbWFnZSgpXG4gICAgICAgIC8vIERvbid0IHNldCBjcm9zc09yaWdpbiBmb3IgbG9jYWwgaW1hZ2VzXG4gICAgICAgIGlmIChpbWFnZVNyYy5zdGFydHNXaXRoKCdodHRwJykpIHtcbiAgICAgICAgICBpbWcuY3Jvc3NPcmlnaW4gPSAnYW5vbnltb3VzJ1xuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICBhd2FpdCBuZXcgUHJvbWlzZTx2b2lkPigocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgICAgaW1nLm9ubG9hZCA9ICgpID0+IHtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKCdJbWFnZSBsb2FkZWQgc3VjY2Vzc2Z1bGx5OicsIGltZy53aWR0aCwgaW1nLmhlaWdodClcbiAgICAgICAgICAgIHJlc29sdmUoKVxuICAgICAgICAgIH1cbiAgICAgICAgICBpbWcub25lcnJvciA9IChlKSA9PiB7XG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKCdJbWFnZSBsb2FkIGVycm9yOicsIGUpXG4gICAgICAgICAgICByZWplY3QobmV3IEVycm9yKCdGYWlsZWQgdG8gbG9hZCBpbWFnZScpKVxuICAgICAgICAgIH1cbiAgICAgICAgICBpbWcuc3JjID0gaW1hZ2VTcmNcbiAgICAgICAgfSlcblxuICAgICAgICAvLyBDcmVhdGUgY2FudmFzIGFuZCBkcmF3IGltYWdlXG4gICAgICAgIGNvbnN0IGNhbnZhcyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2NhbnZhcycpXG4gICAgICAgIGNhbnZhcy53aWR0aCA9IHdpZHRoXG4gICAgICAgIGNhbnZhcy5oZWlnaHQgPSBoZWlnaHRcbiAgICAgICAgY29uc3QgY3R4ID0gY2FudmFzLmdldENvbnRleHQoJzJkJylcbiAgICAgICAgXG4gICAgICAgIGlmICghY3R4KSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdDb3VsZCBub3QgZ2V0IGNhbnZhcyBjb250ZXh0JylcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIERyYXcgaW1hZ2Ugc2NhbGVkIHRvIGNhbnZhcyBzaXplXG4gICAgICAgIGN0eC5kcmF3SW1hZ2UoaW1nLCAwLCAwLCB3aWR0aCwgaGVpZ2h0KVxuICAgICAgICBcbiAgICAgICAgLy8gR2V0IGltYWdlIGRhdGFcbiAgICAgICAgY29uc3QgaW1hZ2VEYXRhID0gY3R4LmdldEltYWdlRGF0YSgwLCAwLCB3aWR0aCwgaGVpZ2h0KVxuICAgICAgICBcbiAgICAgICAgLy8gRGV0ZWN0IGVkZ2VzXG4gICAgICAgIGNvbnN0IHsgZWRnZXMgfSA9IGRldGVjdEVkZ2VzKGltYWdlRGF0YSlcbiAgICAgICAgY29uc29sZS5sb2coJ0VkZ2VzIGRldGVjdGVkLCBtYXggdmFsdWU6JywgTWF0aC5tYXgoLi4uZWRnZXMpKVxuICAgICAgICBcbiAgICAgICAgLy8gU2FtcGxlIHBvaW50cyBhbG9uZyBlZGdlc1xuICAgICAgICBjb25zdCBwb2ludHMgPSBzYW1wbGVFZGdlUG9pbnRzKFxuICAgICAgICAgIGVkZ2VzLFxuICAgICAgICAgIHdpZHRoLFxuICAgICAgICAgIGhlaWdodCxcbiAgICAgICAgICBlZGdlVGhyZXNob2xkLFxuICAgICAgICAgIHBvaW50RGVuc2l0eSxcbiAgICAgICAgICBtYXhQb2ludHNcbiAgICAgICAgKVxuICAgICAgICBjb25zb2xlLmxvZygnUG9pbnRzIHNhbXBsZWQ6JywgcG9pbnRzLmxlbmd0aClcbiAgICAgICAgXG4gICAgICAgIC8vIENyZWF0ZSB0cmlhbmdsZXMgdXNpbmcgRGVsYXVuYXkgdHJpYW5ndWxhdGlvblxuICAgICAgICBjb25zdCB0cmlhbmdsZXMgPSBkZWxhdW5heVRyaWFuZ3VsYXRlKHBvaW50cywgd2lkdGgsIGhlaWdodClcbiAgICAgICAgY29uc29sZS5sb2coJ1RyaWFuZ2xlcyBjcmVhdGVkOicsIHRyaWFuZ2xlcy5sZW5ndGgpXG4gICAgICAgIFxuICAgICAgICBzZXRNZXNoKHsgcG9pbnRzLCB0cmlhbmdsZXMgfSlcbiAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICBjb25zb2xlLmVycm9yKCd1c2VJbWFnZU1lc2ggZXJyb3I6JywgZXJyKVxuICAgICAgICBzZXRFcnJvcihlcnIgaW5zdGFuY2VvZiBFcnJvciA/IGVyci5tZXNzYWdlIDogJ1Vua25vd24gZXJyb3InKVxuICAgICAgICAvLyBGYWxsYmFjayB0byBlbXB0eSBtZXNoXG4gICAgICAgIHNldE1lc2goeyBwb2ludHM6IFtdLCB0cmlhbmdsZXM6IFtdIH0pXG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICBzZXRJc0xvYWRpbmcoZmFsc2UpXG4gICAgICB9XG4gICAgfVxuXG4gICAgcHJvY2Vzc0ltYWdlKClcbiAgfSwgW2ltYWdlU3JjLCB3aWR0aCwgaGVpZ2h0LCBlZGdlVGhyZXNob2xkLCBwb2ludERlbnNpdHksIG1heFBvaW50c10pXG5cbiAgcmV0dXJuIHsgbWVzaCwgaXNMb2FkaW5nLCBlcnJvciB9XG59XG4iXSwibmFtZXMiOlsidXNlU3RhdGUiLCJ1c2VFZmZlY3QiLCJTT0JFTF9YIiwiU09CRUxfWSIsIkdBVVNTSUFOXzN4MyIsImdldFBpeGVsR3JheXNjYWxlIiwiaW1hZ2VEYXRhIiwieCIsInkiLCJpZHgiLCJ3aWR0aCIsInIiLCJkYXRhIiwiZyIsImIiLCJhcHBseUtlcm5lbCIsImdyYXlzY2FsZSIsImhlaWdodCIsImtlcm5lbCIsInN1bSIsImt5Iiwia3giLCJweCIsIk1hdGgiLCJtaW4iLCJtYXgiLCJweSIsImdyYXkiLCJkZXRlY3RFZGdlcyIsIkZsb2F0MzJBcnJheSIsImJsdXJyZWQiLCJlZGdlcyIsImRpcmVjdGlvbnMiLCJneCIsImd5IiwibWFnbml0dWRlIiwic3FydCIsImF0YW4yIiwic3VwcHJlc3NlZCIsImFuZ2xlIiwibWFnIiwibmVpZ2hib3IxIiwibmVpZ2hib3IyIiwibm9ybWFsaXplZEFuZ2xlIiwiUEkiLCJzYW1wbGVFZGdlUG9pbnRzIiwidGhyZXNob2xkIiwiZGVuc2l0eSIsIm1heFBvaW50cyIsInBvaW50cyIsIm1heEVkZ2UiLCJpIiwibGVuZ3RoIiwibm9ybWFsaXplZFRocmVzaG9sZCIsImJhc2VTdGVwIiwiZmxvb3IiLCJlZGdlVmFsdWUiLCJzdHJlbmd0aCIsImppdHRlckFtb3VudCIsImppdHRlclgiLCJyYW5kb20iLCJqaXR0ZXJZIiwicHVzaCIsImlkIiwib2Zmc2V0WCIsIm9mZnNldFkiLCJncmlkU3RlcCIsImhhc05lYXJieSIsInNvbWUiLCJwIiwiYWJzIiwiYm91bmRhcnlTdGVwIiwiZWRnZVBvaW50Q291bnQiLCJib3VuZGFyeVBvaW50cyIsInNsaWNlIiwiZWRnZVBvaW50cyIsInNhbXBsZWRFZGdlIiwic29ydCIsIm1hcCIsImRlbGF1bmF5VHJpYW5ndWxhdGUiLCJtYXJnaW4iLCJzdXBlclBvaW50cyIsInRyaWFuZ2xlcyIsInAxIiwicDIiLCJwMyIsInBvaW50IiwiYmFkVHJpYW5nbGVzIiwidHJpYW5nbGUiLCJpc1BvaW50SW5DaXJjdW1jaXJjbGUiLCJwb2x5Z29uIiwiZWRnZSIsImlzU2hhcmVkIiwib3RoZXIiLCJoYXNFZGdlIiwiZmlsdGVyIiwidCIsImluY2x1ZGVzIiwiZCIsInV4IiwidXkiLCJyYWRpdXNTcSIsImRpc3RTcSIsImhhc1AxIiwiaGFzUDIiLCJ1c2VJbWFnZU1lc2giLCJjb25maWciLCJpbWFnZVNyYyIsImVkZ2VUaHJlc2hvbGQiLCJwb2ludERlbnNpdHkiLCJtZXNoIiwic2V0TWVzaCIsImlzTG9hZGluZyIsInNldElzTG9hZGluZyIsImVycm9yIiwic2V0RXJyb3IiLCJwcm9jZXNzSW1hZ2UiLCJpbWciLCJJbWFnZSIsInN0YXJ0c1dpdGgiLCJjcm9zc09yaWdpbiIsIlByb21pc2UiLCJyZXNvbHZlIiwicmVqZWN0Iiwib25sb2FkIiwiY29uc29sZSIsImxvZyIsIm9uZXJyb3IiLCJlIiwiRXJyb3IiLCJzcmMiLCJjYW52YXMiLCJkb2N1bWVudCIsImNyZWF0ZUVsZW1lbnQiLCJjdHgiLCJnZXRDb250ZXh0IiwiZHJhd0ltYWdlIiwiZ2V0SW1hZ2VEYXRhIiwiZXJyIiwibWVzc2FnZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./components/portrait/useImageMesh.ts\n"));

/***/ })

});