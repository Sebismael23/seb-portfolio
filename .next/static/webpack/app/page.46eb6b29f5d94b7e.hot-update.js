"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/page",{

/***/ "(app-pages-browser)/./components/portrait/useImageMesh.ts":
/*!*********************************************!*\
  !*** ./components/portrait/useImageMesh.ts ***!
  \*********************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   useImageMesh: function() { return /* binding */ useImageMesh; }\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);\n/* __next_internal_client_entry_do_not_use__ useImageMesh auto */ \n// Sobel edge detection kernels\nconst SOBEL_X = [\n    [\n        -1,\n        0,\n        1\n    ],\n    [\n        -2,\n        0,\n        2\n    ],\n    [\n        -1,\n        0,\n        1\n    ]\n];\nconst SOBEL_Y = [\n    [\n        -1,\n        -2,\n        -1\n    ],\n    [\n        0,\n        0,\n        0\n    ],\n    [\n        1,\n        2,\n        1\n    ]\n];\nfunction getPixelGrayscale(imageData, x, y) {\n    const idx = (y * imageData.width + x) * 4;\n    const r = imageData.data[idx];\n    const g = imageData.data[idx + 1];\n    const b = imageData.data[idx + 2];\n    // Luminance formula\n    return 0.299 * r + 0.587 * g + 0.114 * b;\n}\nfunction applyKernel(imageData, x, y, kernel) {\n    let sum = 0;\n    for(let ky = -1; ky <= 1; ky++){\n        for(let kx = -1; kx <= 1; kx++){\n            const px = Math.min(Math.max(x + kx, 0), imageData.width - 1);\n            const py = Math.min(Math.max(y + ky, 0), imageData.height - 1);\n            const gray = getPixelGrayscale(imageData, px, py);\n            sum += gray * kernel[ky + 1][kx + 1];\n        }\n    }\n    return sum;\n}\nfunction detectEdges(imageData) {\n    const edges = new Float32Array(imageData.width * imageData.height);\n    for(let y = 1; y < imageData.height - 1; y++){\n        for(let x = 1; x < imageData.width - 1; x++){\n            const gx = applyKernel(imageData, x, y, SOBEL_X);\n            const gy = applyKernel(imageData, x, y, SOBEL_Y);\n            const magnitude = Math.sqrt(gx * gx + gy * gy);\n            edges[y * imageData.width + x] = magnitude;\n        }\n    }\n    return edges;\n}\nfunction sampleEdgePoints(edges, width, height, threshold, density, maxPoints) {\n    const points = [];\n    const step = Math.max(1, Math.floor(1 / density));\n    // Sample points along edges\n    for(let y = step; y < height - step; y += step){\n        for(let x = step; x < width - step; x += step){\n            const edgeValue = edges[y * width + x];\n            if (edgeValue > threshold) {\n                // Add some jitter for more organic look\n                const jitterX = (Math.random() - 0.5) * step * 0.5;\n                const jitterY = (Math.random() - 0.5) * step * 0.5;\n                points.push({\n                    x: x + jitterX,\n                    y: y + jitterY,\n                    id: points.length\n                });\n            }\n        }\n    }\n    // Add boundary points for better triangulation\n    const boundaryStep = Math.max(20, width / 15);\n    for(let x = 0; x <= width; x += boundaryStep){\n        points.push({\n            x,\n            y: 0,\n            id: points.length\n        });\n        points.push({\n            x,\n            y: height,\n            id: points.length\n        });\n    }\n    for(let y = boundaryStep; y < height; y += boundaryStep){\n        points.push({\n            x: 0,\n            y,\n            id: points.length\n        });\n        points.push({\n            x: width,\n            y,\n            id: points.length\n        });\n    }\n    // Add corner points\n    points.push({\n        x: 0,\n        y: 0,\n        id: points.length\n    });\n    points.push({\n        x: width,\n        y: 0,\n        id: points.length\n    });\n    points.push({\n        x: 0,\n        y: height,\n        id: points.length\n    });\n    points.push({\n        x: width,\n        y: height,\n        id: points.length\n    });\n    // Limit points if too many\n    if (points.length > maxPoints) {\n        // Keep boundary points and randomly sample edge points\n        const boundaryCount = Math.floor(width / boundaryStep) * 2 + Math.floor(height / boundaryStep) * 2 + 4;\n        const edgePoints = points.slice(0, points.length - boundaryCount);\n        const boundaryPoints = points.slice(points.length - boundaryCount);\n        // Randomly sample edge points\n        const sampledEdge = edgePoints.sort(()=>Math.random() - 0.5).slice(0, maxPoints - boundaryCount);\n        return [\n            ...sampledEdge,\n            ...boundaryPoints\n        ].map((p, i)=>({\n                ...p,\n                id: i\n            }));\n    }\n    return points;\n}\n// Delaunay triangulation using Bowyer-Watson algorithm\nfunction delaunayTriangulate(points, width, height) {\n    if (points.length < 3) return [];\n    // Create super triangle that contains all points\n    const margin = Math.max(width, height) * 3;\n    const superPoints = [\n        {\n            x: width / 2,\n            y: -margin,\n            id: -1\n        },\n        {\n            x: -margin,\n            y: height + margin,\n            id: -2\n        },\n        {\n            x: width + margin,\n            y: height + margin,\n            id: -3\n        }\n    ];\n    let triangles = [\n        {\n            p1: superPoints[0],\n            p2: superPoints[1],\n            p3: superPoints[2]\n        }\n    ];\n    // Add points one at a time\n    for (const point of points){\n        const badTriangles = [];\n        // Find all triangles whose circumcircle contains the point\n        for (const triangle of triangles){\n            if (isPointInCircumcircle(point, triangle)) {\n                badTriangles.push(triangle);\n            }\n        }\n        // If no bad triangles found, skip this point\n        if (badTriangles.length === 0) continue;\n        // Find the boundary of the polygonal hole\n        const polygon = [];\n        for (const triangle of badTriangles){\n            const edges = [\n                {\n                    p1: triangle.p1,\n                    p2: triangle.p2\n                },\n                {\n                    p1: triangle.p2,\n                    p2: triangle.p3\n                },\n                {\n                    p1: triangle.p3,\n                    p2: triangle.p1\n                }\n            ];\n            for (const edge of edges){\n                // Check if edge is shared with another bad triangle\n                let isShared = false;\n                for (const other of badTriangles){\n                    if (other === triangle) continue;\n                    if (hasEdge(other, edge)) {\n                        isShared = true;\n                        break;\n                    }\n                }\n                if (!isShared) {\n                    polygon.push(edge);\n                }\n            }\n        }\n        // Remove bad triangles\n        triangles = triangles.filter((t)=>!badTriangles.includes(t));\n        // Create new triangles from polygon edges to point\n        for (const edge of polygon){\n            triangles.push({\n                p1: edge.p1,\n                p2: edge.p2,\n                p3: point\n            });\n        }\n    }\n    // Remove triangles that share vertices with super triangle\n    triangles = triangles.filter((t)=>t.p1.id >= 0 && t.p2.id >= 0 && t.p3.id >= 0);\n    return triangles;\n}\n// Calculate circumcircle and check if point is inside\nfunction isPointInCircumcircle(point, triangle) {\n    const { p1, p2, p3 } = triangle;\n    // Calculate the circumcenter\n    const d = 2 * (p1.x * (p2.y - p3.y) + p2.x * (p3.y - p1.y) + p3.x * (p1.y - p2.y));\n    if (Math.abs(d) < 1e-10) return false // Degenerate triangle\n    ;\n    const ux = ((p1.x * p1.x + p1.y * p1.y) * (p2.y - p3.y) + (p2.x * p2.x + p2.y * p2.y) * (p3.y - p1.y) + (p3.x * p3.x + p3.y * p3.y) * (p1.y - p2.y)) / d;\n    const uy = ((p1.x * p1.x + p1.y * p1.y) * (p3.x - p2.x) + (p2.x * p2.x + p2.y * p2.y) * (p1.x - p3.x) + (p3.x * p3.x + p3.y * p3.y) * (p2.x - p1.x)) / d;\n    // Circumradius squared\n    const radiusSq = (p1.x - ux) * (p1.x - ux) + (p1.y - uy) * (p1.y - uy);\n    // Distance from point to circumcenter squared\n    const distSq = (point.x - ux) * (point.x - ux) + (point.y - uy) * (point.y - uy);\n    return distSq <= radiusSq;\n}\nfunction hasEdge(triangle, edge) {\n    const points = [\n        triangle.p1,\n        triangle.p2,\n        triangle.p3\n    ];\n    let hasP1 = false;\n    let hasP2 = false;\n    for (const p of points){\n        if (p.id === edge.p1.id) hasP1 = true;\n        if (p.id === edge.p2.id) hasP2 = true;\n    }\n    return hasP1 && hasP2;\n}\nfunction useImageMesh(config) {\n    const { imageSrc, width, height, edgeThreshold = 50, pointDensity = 0.08, maxPoints = 500 } = config;\n    const [mesh, setMesh] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)({\n        points: [],\n        triangles: []\n    });\n    const [isLoading, setIsLoading] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(true);\n    const [error, setError] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(null);\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        if (!imageSrc) {\n            setIsLoading(false);\n            return;\n        }\n        const processImage = async ()=>{\n            setIsLoading(true);\n            setError(null);\n            try {\n                // Create image element\n                const img = new Image();\n                // Don't set crossOrigin for local images\n                if (imageSrc.startsWith(\"http\")) {\n                    img.crossOrigin = \"anonymous\";\n                }\n                await new Promise((resolve, reject)=>{\n                    img.onload = ()=>{\n                        console.log(\"Image loaded successfully:\", img.width, img.height);\n                        resolve();\n                    };\n                    img.onerror = (e)=>{\n                        console.error(\"Image load error:\", e);\n                        reject(new Error(\"Failed to load image\"));\n                    };\n                    img.src = imageSrc;\n                });\n                // Create canvas and draw image\n                const canvas = document.createElement(\"canvas\");\n                canvas.width = width;\n                canvas.height = height;\n                const ctx = canvas.getContext(\"2d\");\n                if (!ctx) {\n                    throw new Error(\"Could not get canvas context\");\n                }\n                // Draw image scaled to canvas size\n                ctx.drawImage(img, 0, 0, width, height);\n                // Get image data\n                const imageData = ctx.getImageData(0, 0, width, height);\n                // Detect edges\n                const edges = detectEdges(imageData);\n                console.log(\"Edges detected, max value:\", Math.max(...edges));\n                // Sample points along edges\n                const points = sampleEdgePoints(edges, width, height, edgeThreshold, pointDensity, maxPoints);\n                console.log(\"Points sampled:\", points.length);\n                // Create triangles using Delaunay triangulation\n                const triangles = delaunayTriangulate(points, width, height);\n                console.log(\"Triangles created:\", triangles.length);\n                setMesh({\n                    points,\n                    triangles\n                });\n            } catch (err) {\n                console.error(\"useImageMesh error:\", err);\n                setError(err instanceof Error ? err.message : \"Unknown error\");\n                // Fallback to empty mesh\n                setMesh({\n                    points: [],\n                    triangles: []\n                });\n            } finally{\n                setIsLoading(false);\n            }\n        };\n        processImage();\n    }, [\n        imageSrc,\n        width,\n        height,\n        edgeThreshold,\n        pointDensity,\n        maxPoints\n    ]);\n    return {\n        mesh,\n        isLoading,\n        error\n    };\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL2NvbXBvbmVudHMvcG9ydHJhaXQvdXNlSW1hZ2VNZXNoLnRzIiwibWFwcGluZ3MiOiI7Ozs7OztrRUFFMkM7QUFZM0MsK0JBQStCO0FBQy9CLE1BQU1FLFVBQVU7SUFDZDtRQUFDLENBQUM7UUFBRztRQUFHO0tBQUU7SUFDVjtRQUFDLENBQUM7UUFBRztRQUFHO0tBQUU7SUFDVjtRQUFDLENBQUM7UUFBRztRQUFHO0tBQUU7Q0FDWDtBQUVELE1BQU1DLFVBQVU7SUFDZDtRQUFDLENBQUM7UUFBRyxDQUFDO1FBQUcsQ0FBQztLQUFFO0lBQ1o7UUFBQztRQUFHO1FBQUc7S0FBRTtJQUNUO1FBQUM7UUFBRztRQUFHO0tBQUU7Q0FDVjtBQUVELFNBQVNDLGtCQUNQQyxTQUFvQixFQUNwQkMsQ0FBUyxFQUNUQyxDQUFTO0lBRVQsTUFBTUMsTUFBTSxDQUFDRCxJQUFJRixVQUFVSSxLQUFLLEdBQUdILENBQUFBLElBQUs7SUFDeEMsTUFBTUksSUFBSUwsVUFBVU0sSUFBSSxDQUFDSCxJQUFJO0lBQzdCLE1BQU1JLElBQUlQLFVBQVVNLElBQUksQ0FBQ0gsTUFBTSxFQUFFO0lBQ2pDLE1BQU1LLElBQUlSLFVBQVVNLElBQUksQ0FBQ0gsTUFBTSxFQUFFO0lBQ2pDLG9CQUFvQjtJQUNwQixPQUFPLFFBQVFFLElBQUksUUFBUUUsSUFBSSxRQUFRQztBQUN6QztBQUVBLFNBQVNDLFlBQ1BULFNBQW9CLEVBQ3BCQyxDQUFTLEVBQ1RDLENBQVMsRUFDVFEsTUFBa0I7SUFFbEIsSUFBSUMsTUFBTTtJQUNWLElBQUssSUFBSUMsS0FBSyxDQUFDLEdBQUdBLE1BQU0sR0FBR0EsS0FBTTtRQUMvQixJQUFLLElBQUlDLEtBQUssQ0FBQyxHQUFHQSxNQUFNLEdBQUdBLEtBQU07WUFDL0IsTUFBTUMsS0FBS0MsS0FBS0MsR0FBRyxDQUFDRCxLQUFLRSxHQUFHLENBQUNoQixJQUFJWSxJQUFJLElBQUliLFVBQVVJLEtBQUssR0FBRztZQUMzRCxNQUFN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UUMsR0FBRyxDQUFDLDhCQUE4QnJGLEtBQUtFLEdBQUcsSUFBSUs7Z0JBRXRELDRCQUE0QjtnQkFDNUIsTUFBTVUsU0FBU0osaUJBQ2JOLE9BQ0FsQixPQUNBZSxRQUNBK0QsZUFDQUMsY0FDQXBEO2dCQUVGb0UsUUFBUUMsR0FBRyxDQUFDLG1CQUFtQnBFLE9BQU9TLE1BQU07Z0JBRTVDLGdEQUFnRDtnQkFDaEQsTUFBTWMsWUFBWUgsb0JBQW9CcEIsUUFBUTVCLE9BQU9lO2dCQUNyRGdGLFFBQVFDLEdBQUcsQ0FBQyxzQkFBc0I3QyxVQUFVZCxNQUFNO2dCQUVsRDRDLFFBQVE7b0JBQUVyRDtvQkFBUXVCO2dCQUFVO1lBQzlCLEVBQUUsT0FBT3lELEtBQUs7Z0JBQ1piLFFBQVFYLEtBQUssQ0FBQyx1QkFBdUJ3QjtnQkFDckN2QixTQUFTdUIsZUFBZVQsUUFBUVMsSUFBSUMsT0FBTyxHQUFHO2dCQUM5Qyx5QkFBeUI7Z0JBQ3pCNUIsUUFBUTtvQkFBRXJELFFBQVEsRUFBRTtvQkFBRXVCLFdBQVcsRUFBRTtnQkFBQztZQUN0QyxTQUFVO2dCQUNSZ0MsYUFBYTtZQUNmO1FBQ0Y7UUFFQUc7SUFDRixHQUFHO1FBQUNUO1FBQVU3RTtRQUFPZTtRQUFRK0Q7UUFBZUM7UUFBY3BEO0tBQVU7SUFFcEUsT0FBTztRQUFFcUQ7UUFBTUU7UUFBV0U7SUFBTTtBQUNsQyIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9jb21wb25lbnRzL3BvcnRyYWl0L3VzZUltYWdlTWVzaC50cz85MGQ5Il0sInNvdXJjZXNDb250ZW50IjpbIid1c2UgY2xpZW50J1xuXG5pbXBvcnQgeyB1c2VTdGF0ZSwgdXNlRWZmZWN0IH0gZnJvbSAncmVhY3QnXG5pbXBvcnQgdHlwZSB7IE1lc2gsIFBvaW50LCBUcmlhbmdsZSB9IGZyb20gJy4vdHlwZXMnXG5cbmludGVyZmFjZSBJbWFnZU1lc2hDb25maWcge1xuICBpbWFnZVNyYzogc3RyaW5nXG4gIHdpZHRoOiBudW1iZXJcbiAgaGVpZ2h0OiBudW1iZXJcbiAgZWRnZVRocmVzaG9sZD86IG51bWJlclxuICBwb2ludERlbnNpdHk/OiBudW1iZXJcbiAgbWF4UG9pbnRzPzogbnVtYmVyXG59XG5cbi8vIFNvYmVsIGVkZ2UgZGV0ZWN0aW9uIGtlcm5lbHNcbmNvbnN0IFNPQkVMX1ggPSBbXG4gIFstMSwgMCwgMV0sXG4gIFstMiwgMCwgMl0sXG4gIFstMSwgMCwgMV0sXG5dXG5cbmNvbnN0IFNPQkVMX1kgPSBbXG4gIFstMSwgLTIsIC0xXSxcbiAgWzAsIDAsIDBdLFxuICBbMSwgMiwgMV0sXG5dXG5cbmZ1bmN0aW9uIGdldFBpeGVsR3JheXNjYWxlKFxuICBpbWFnZURhdGE6IEltYWdlRGF0YSxcbiAgeDogbnVtYmVyLFxuICB5OiBudW1iZXJcbik6IG51bWJlciB7XG4gIGNvbnN0IGlkeCA9ICh5ICogaW1hZ2VEYXRhLndpZHRoICsgeCkgKiA0XG4gIGNvbnN0IHIgPSBpbWFnZURhdGEuZGF0YVtpZHhdXG4gIGNvbnN0IGcgPSBpbWFnZURhdGEuZGF0YVtpZHggKyAxXVxuICBjb25zdCBiID0gaW1hZ2VEYXRhLmRhdGFbaWR4ICsgMl1cbiAgLy8gTHVtaW5hbmNlIGZvcm11bGFcbiAgcmV0dXJuIDAuMjk5ICogciArIDAuNTg3ICogZyArIDAuMTE0ICogYlxufVxuXG5mdW5jdGlvbiBhcHBseUtlcm5lbChcbiAgaW1hZ2VEYXRhOiBJbWFnZURhdGEsXG4gIHg6IG51bWJlcixcbiAgeTogbnVtYmVyLFxuICBrZXJuZWw6IG51bWJlcltdW11cbik6IG51bWJlciB7XG4gIGxldCBzdW0gPSAwXG4gIGZvciAobGV0IGt5ID0gLTE7IGt5IDw9IDE7IGt5KyspIHtcbiAgICBmb3IgKGxldCBreCA9IC0xOyBreCA8PSAxOyBreCsrKSB7XG4gICAgICBjb25zdCBweCA9IE1hdGgubWluKE1hdGgubWF4KHggKyBreCwgMCksIGltYWdlRGF0YS53aWR0aCAtIDEpXG4gICAgICBjb25zdCBweSA9IE1hdGgubWluKE1hdGgubWF4KHkgKyBreSwgMCksIGltYWdlRGF0YS5oZWlnaHQgLSAxKVxuICAgICAgY29uc3QgZ3JheSA9IGdldFBpeGVsR3JheXNjYWxlKGltYWdlRGF0YSwgcHgsIHB5KVxuICAgICAgc3VtICs9IGdyYXkgKiBrZXJuZWxba3kgKyAxXVtreCArIDFdXG4gICAgfVxuICB9XG4gIHJldHVybiBzdW1cbn1cblxuZnVuY3Rpb24gZGV0ZWN0RWRnZXMoaW1hZ2VEYXRhOiBJbWFnZURhdGEpOiBGbG9hdDMyQXJyYXkge1xuICBjb25zdCBlZGdlcyA9IG5ldyBGbG9hdDMyQXJyYXkoaW1hZ2VEYXRhLndpZHRoICogaW1hZ2VEYXRhLmhlaWdodClcbiAgXG4gIGZvciAobGV0IHkgPSAxOyB5IDwgaW1hZ2VEYXRhLmhlaWdodCAtIDE7IHkrKykge1xuICAgIGZvciAobGV0IHggPSAxOyB4IDwgaW1hZ2VEYXRhLndpZHRoIC0gMTsgeCsrKSB7XG4gICAgICBjb25zdCBneCA9IGFwcGx5S2VybmVsKGltYWdlRGF0YSwgeCwgeSwgU09CRUxfWClcbiAgICAgIGNvbnN0IGd5ID0gYXBwbHlLZXJuZWwoaW1hZ2VEYXRhLCB4LCB5LCBTT0JFTF9ZKVxuICAgICAgY29uc3QgbWFnbml0dWRlID0gTWF0aC5zcXJ0KGd4ICogZ3ggKyBneSAqIGd5KVxuICAgICAgZWRnZXNbeSAqIGltYWdlRGF0YS53aWR0aCArIHhdID0gbWFnbml0dWRlXG4gICAgfVxuICB9XG4gIFxuICByZXR1cm4gZWRnZXNcbn1cblxuZnVuY3Rpb24gc2FtcGxlRWRnZVBvaW50cyhcbiAgZWRnZXM6IEZsb2F0MzJBcnJheSxcbiAgd2lkdGg6IG51bWJlcixcbiAgaGVpZ2h0OiBudW1iZXIsXG4gIHRocmVzaG9sZDogbnVtYmVyLFxuICBkZW5zaXR5OiBudW1iZXIsXG4gIG1heFBvaW50czogbnVtYmVyXG4pOiBQb2ludFtdIHtcbiAgY29uc3QgcG9pbnRzOiBQb2ludFtdID0gW11cbiAgY29uc3Qgc3RlcCA9IE1hdGgubWF4KDEsIE1hdGguZmxvb3IoMSAvIGRlbnNpdHkpKVxuICBcbiAgLy8gU2FtcGxlIHBvaW50cyBhbG9uZyBlZGdlc1xuICBmb3IgKGxldCB5ID0gc3RlcDsgeSA8IGhlaWdodCAtIHN0ZXA7IHkgKz0gc3RlcCkge1xuICAgIGZvciAobGV0IHggPSBzdGVwOyB4IDwgd2lkdGggLSBzdGVwOyB4ICs9IHN0ZXApIHtcbiAgICAgIGNvbnN0IGVkZ2VWYWx1ZSA9IGVkZ2VzW3kgKiB3aWR0aCArIHhdXG4gICAgICBpZiAoZWRnZVZhbHVlID4gdGhyZXNob2xkKSB7XG4gICAgICAgIC8vIEFkZCBzb21lIGppdHRlciBmb3IgbW9yZSBvcmdhbmljIGxvb2tcbiAgICAgICAgY29uc3Qgaml0dGVyWCA9IChNYXRoLnJhbmRvbSgpIC0gMC41KSAqIHN0ZXAgKiAwLjVcbiAgICAgICAgY29uc3Qgaml0dGVyWSA9IChNYXRoLnJhbmRvbSgpIC0gMC41KSAqIHN0ZXAgKiAwLjVcbiAgICAgICAgcG9pbnRzLnB1c2goe1xuICAgICAgICAgIHg6IHggKyBqaXR0ZXJYLFxuICAgICAgICAgIHk6IHkgKyBqaXR0ZXJZLFxuICAgICAgICAgIGlkOiBwb2ludHMubGVuZ3RoLFxuICAgICAgICB9KVxuICAgICAgfVxuICAgIH1cbiAgfVxuICBcbiAgLy8gQWRkIGJvdW5kYXJ5IHBvaW50cyBmb3IgYmV0dGVyIHRyaWFuZ3VsYXRpb25cbiAgY29uc3QgYm91bmRhcnlTdGVwID0gTWF0aC5tYXgoMjAsIHdpZHRoIC8gMTUpXG4gIGZvciAobGV0IHggPSAwOyB4IDw9IHdpZHRoOyB4ICs9IGJvdW5kYXJ5U3RlcCkge1xuICAgIHBvaW50cy5wdXNoKHsgeCwgeTogMCwgaWQ6IHBvaW50cy5sZW5ndGggfSlcbiAgICBwb2ludHMucHVzaCh7IHgsIHk6IGhlaWdodCwgaWQ6IHBvaW50cy5sZW5ndGggfSlcbiAgfVxuICBmb3IgKGxldCB5ID0gYm91bmRhcnlTdGVwOyB5IDwgaGVpZ2h0OyB5ICs9IGJvdW5kYXJ5U3RlcCkge1xuICAgIHBvaW50cy5wdXNoKHsgeDogMCwgeSwgaWQ6IHBvaW50cy5sZW5ndGggfSlcbiAgICBwb2ludHMucHVzaCh7IHg6IHdpZHRoLCB5LCBpZDogcG9pbnRzLmxlbmd0aCB9KVxuICB9XG4gIFxuICAvLyBBZGQgY29ybmVyIHBvaW50c1xuICBwb2ludHMucHVzaCh7IHg6IDAsIHk6IDAsIGlkOiBwb2ludHMubGVuZ3RoIH0pXG4gIHBvaW50cy5wdXNoKHsgeDogd2lkdGgsIHk6IDAsIGlkOiBwb2ludHMubGVuZ3RoIH0pXG4gIHBvaW50cy5wdXNoKHsgeDogMCwgeTogaGVpZ2h0LCBpZDogcG9pbnRzLmxlbmd0aCB9KVxuICBwb2ludHMucHVzaCh7IHg6IHdpZHRoLCB5OiBoZWlnaHQsIGlkOiBwb2ludHMubGVuZ3RoIH0pXG4gIFxuICAvLyBMaW1pdCBwb2ludHMgaWYgdG9vIG1hbnlcbiAgaWYgKHBvaW50cy5sZW5ndGggPiBtYXhQb2ludHMpIHtcbiAgICAvLyBLZWVwIGJvdW5kYXJ5IHBvaW50cyBhbmQgcmFuZG9tbHkgc2FtcGxlIGVkZ2UgcG9pbnRzXG4gICAgY29uc3QgYm91bmRhcnlDb3VudCA9IE1hdGguZmxvb3Iod2lkdGggLyBib3VuZGFyeVN0ZXApICogMiArIE1hdGguZmxvb3IoaGVpZ2h0IC8gYm91bmRhcnlTdGVwKSAqIDIgKyA0XG4gICAgY29uc3QgZWRnZVBvaW50cyA9IHBvaW50cy5zbGljZSgwLCBwb2ludHMubGVuZ3RoIC0gYm91bmRhcnlDb3VudClcbiAgICBjb25zdCBib3VuZGFyeVBvaW50cyA9IHBvaW50cy5zbGljZShwb2ludHMubGVuZ3RoIC0gYm91bmRhcnlDb3VudClcbiAgICBcbiAgICAvLyBSYW5kb21seSBzYW1wbGUgZWRnZSBwb2ludHNcbiAgICBjb25zdCBzYW1wbGVkRWRnZSA9IGVkZ2VQb2ludHNcbiAgICAgIC5zb3J0KCgpID0+IE1hdGgucmFuZG9tKCkgLSAwLjUpXG4gICAgICAuc2xpY2UoMCwgbWF4UG9pbnRzIC0gYm91bmRhcnlDb3VudClcbiAgICBcbiAgICByZXR1cm4gWy4uLnNhbXBsZWRFZGdlLCAuLi5ib3VuZGFyeVBvaW50c10ubWFwKChwLCBpKSA9PiAoeyAuLi5wLCBpZDogaSB9KSlcbiAgfVxuICBcbiAgcmV0dXJuIHBvaW50c1xufVxuXG4vLyBEZWxhdW5heSB0cmlhbmd1bGF0aW9uIHVzaW5nIEJvd3llci1XYXRzb24gYWxnb3JpdGhtXG5mdW5jdGlvbiBkZWxhdW5heVRyaWFuZ3VsYXRlKHBvaW50czogUG9pbnRbXSwgd2lkdGg6IG51bWJlciwgaGVpZ2h0OiBudW1iZXIpOiBUcmlhbmdsZVtdIHtcbiAgaWYgKHBvaW50cy5sZW5ndGggPCAzKSByZXR1cm4gW11cbiAgXG4gIC8vIENyZWF0ZSBzdXBlciB0cmlhbmdsZSB0aGF0IGNvbnRhaW5zIGFsbCBwb2ludHNcbiAgY29uc3QgbWFyZ2luID0gTWF0aC5tYXgod2lkdGgsIGhlaWdodCkgKiAzXG4gIGNvbnN0IHN1cGVyUG9pbnRzOiBQb2ludFtdID0gW1xuICAgIHsgeDogd2lkdGggLyAyLCB5OiAtbWFyZ2luLCBpZDogLTEgfSxcbiAgICB7IHg6IC1tYXJnaW4sIHk6IGhlaWdodCArIG1hcmdpbiwgaWQ6IC0yIH0sXG4gICAgeyB4OiB3aWR0aCArIG1hcmdpbiwgeTogaGVpZ2h0ICsgbWFyZ2luLCBpZDogLTMgfSxcbiAgXVxuICBcbiAgbGV0IHRyaWFuZ2xlczogVHJpYW5nbGVbXSA9IFt7XG4gICAgcDE6IHN1cGVyUG9pbnRzWzBdLFxuICAgIHAyOiBzdXBlclBvaW50c1sxXSxcbiAgICBwMzogc3VwZXJQb2ludHNbMl0sXG4gIH1dXG4gIFxuICAvLyBBZGQgcG9pbnRzIG9uZSBhdCBhIHRpbWVcbiAgZm9yIChjb25zdCBwb2ludCBvZiBwb2ludHMpIHtcbiAgICBjb25zdCBiYWRUcmlhbmdsZXM6IFRyaWFuZ2xlW10gPSBbXVxuICAgIFxuICAgIC8vIEZpbmQgYWxsIHRyaWFuZ2xlcyB3aG9zZSBjaXJjdW1jaXJjbGUgY29udGFpbnMgdGhlIHBvaW50XG4gICAgZm9yIChjb25zdCB0cmlhbmdsZSBvZiB0cmlhbmdsZXMpIHtcbiAgICAgIGlmIChpc1BvaW50SW5DaXJjdW1jaXJjbGUocG9pbnQsIHRyaWFuZ2xlKSkge1xuICAgICAgICBiYWRUcmlhbmdsZXMucHVzaCh0cmlhbmdsZSlcbiAgICAgIH1cbiAgICB9XG4gICAgXG4gICAgLy8gSWYgbm8gYmFkIHRyaWFuZ2xlcyBmb3VuZCwgc2tpcCB0aGlzIHBvaW50XG4gICAgaWYgKGJhZFRyaWFuZ2xlcy5sZW5ndGggPT09IDApIGNvbnRpbnVlXG4gICAgXG4gICAgLy8gRmluZCB0aGUgYm91bmRhcnkgb2YgdGhlIHBvbHlnb25hbCBob2xlXG4gICAgY29uc3QgcG9seWdvbjogQXJyYXk8eyBwMTogUG9pbnQ7IHAyOiBQb2ludCB9PiA9IFtdXG4gICAgXG4gICAgZm9yIChjb25zdCB0cmlhbmdsZSBvZiBiYWRUcmlhbmdsZXMpIHtcbiAgICAgIGNvbnN0IGVkZ2VzID0gW1xuICAgICAgICB7IHAxOiB0cmlhbmdsZS5wMSwgcDI6IHRyaWFuZ2xlLnAyIH0sXG4gICAgICAgIHsgcDE6IHRyaWFuZ2xlLnAyLCBwMjogdHJpYW5nbGUucDMgfSxcbiAgICAgICAgeyBwMTogdHJpYW5nbGUucDMsIHAyOiB0cmlhbmdsZS5wMSB9LFxuICAgICAgXVxuICAgICAgXG4gICAgICBmb3IgKGNvbnN0IGVkZ2Ugb2YgZWRnZXMpIHtcbiAgICAgICAgLy8gQ2hlY2sgaWYgZWRnZSBpcyBzaGFyZWQgd2l0aCBhbm90aGVyIGJhZCB0cmlhbmdsZVxuICAgICAgICBsZXQgaXNTaGFyZWQgPSBmYWxzZVxuICAgICAgICBmb3IgKGNvbnN0IG90aGVyIG9mIGJhZFRyaWFuZ2xlcykge1xuICAgICAgICAgIGlmIChvdGhlciA9PT0gdHJpYW5nbGUpIGNvbnRpbnVlXG4gICAgICAgICAgaWYgKGhhc0VkZ2Uob3RoZXIsIGVkZ2UpKSB7XG4gICAgICAgICAgICBpc1NoYXJlZCA9IHRydWVcbiAgICAgICAgICAgIGJyZWFrXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICghaXNTaGFyZWQpIHtcbiAgICAgICAgICBwb2x5Z29uLnB1c2goZWRnZSlcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBcbiAgICAvLyBSZW1vdmUgYmFkIHRyaWFuZ2xlc1xuICAgIHRyaWFuZ2xlcyA9IHRyaWFuZ2xlcy5maWx0ZXIoKHQpID0+ICFiYWRUcmlhbmdsZXMuaW5jbHVkZXModCkpXG4gICAgXG4gICAgLy8gQ3JlYXRlIG5ldyB0cmlhbmdsZXMgZnJvbSBwb2x5Z29uIGVkZ2VzIHRvIHBvaW50XG4gICAgZm9yIChjb25zdCBlZGdlIG9mIHBvbHlnb24pIHtcbiAgICAgIHRyaWFuZ2xlcy5wdXNoKHtcbiAgICAgICAgcDE6IGVkZ2UucDEsXG4gICAgICAgIHAyOiBlZGdlLnAyLFxuICAgICAgICBwMzogcG9pbnQsXG4gICAgICB9KVxuICAgIH1cbiAgfVxuICBcbiAgLy8gUmVtb3ZlIHRyaWFuZ2xlcyB0aGF0IHNoYXJlIHZlcnRpY2VzIHdpdGggc3VwZXIgdHJpYW5nbGVcbiAgdHJpYW5nbGVzID0gdHJpYW5nbGVzLmZpbHRlcihcbiAgICAodCkgPT5cbiAgICAgIHQucDEuaWQgPj0gMCAmJlxuICAgICAgdC5wMi5pZCA+PSAwICYmXG4gICAgICB0LnAzLmlkID49IDBcbiAgKVxuICBcbiAgcmV0dXJuIHRyaWFuZ2xlc1xufVxuXG4vLyBDYWxjdWxhdGUgY2lyY3VtY2lyY2xlIGFuZCBjaGVjayBpZiBwb2ludCBpcyBpbnNpZGVcbmZ1bmN0aW9uIGlzUG9pbnRJbkNpcmN1bWNpcmNsZShwb2ludDogUG9pbnQsIHRyaWFuZ2xlOiBUcmlhbmdsZSk6IGJvb2xlYW4ge1xuICBjb25zdCB7IHAxLCBwMiwgcDMgfSA9IHRyaWFuZ2xlXG4gIFxuICAvLyBDYWxjdWxhdGUgdGhlIGNpcmN1bWNlbnRlclxuICBjb25zdCBkID0gMiAqIChwMS54ICogKHAyLnkgLSBwMy55KSArIHAyLnggKiAocDMueSAtIHAxLnkpICsgcDMueCAqIChwMS55IC0gcDIueSkpXG4gIFxuICBpZiAoTWF0aC5hYnMoZCkgPCAxZS0xMCkgcmV0dXJuIGZhbHNlIC8vIERlZ2VuZXJhdGUgdHJpYW5nbGVcbiAgXG4gIGNvbnN0IHV4ID0gKChwMS54ICogcDEueCArIHAxLnkgKiBwMS55KSAqIChwMi55IC0gcDMueSkgKyBcbiAgICAgICAgICAgICAgKHAyLnggKiBwMi54ICsgcDIueSAqIHAyLnkpICogKHAzLnkgLSBwMS55KSArIFxuICAgICAgICAgICAgICAocDMueCAqIHAzLnggKyBwMy55ICogcDMueSkgKiAocDEueSAtIHAyLnkpKSAvIGRcbiAgY29uc3QgdXkgPSAoKHAxLnggKiBwMS54ICsgcDEueSAqIHAxLnkpICogKHAzLnggLSBwMi54KSArIFxuICAgICAgICAgICAgICAocDIueCAqIHAyLnggKyBwMi55ICogcDIueSkgKiAocDEueCAtIHAzLngpICsgXG4gICAgICAgICAgICAgIChwMy54ICogcDMueCArIHAzLnkgKiBwMy55KSAqIChwMi54IC0gcDEueCkpIC8gZFxuICBcbiAgLy8gQ2lyY3VtcmFkaXVzIHNxdWFyZWRcbiAgY29uc3QgcmFkaXVzU3EgPSAocDEueCAtIHV4KSAqIChwMS54IC0gdXgpICsgKHAxLnkgLSB1eSkgKiAocDEueSAtIHV5KVxuICBcbiAgLy8gRGlzdGFuY2UgZnJvbSBwb2ludCB0byBjaXJjdW1jZW50ZXIgc3F1YXJlZFxuICBjb25zdCBkaXN0U3EgPSAocG9pbnQueCAtIHV4KSAqIChwb2ludC54IC0gdXgpICsgKHBvaW50LnkgLSB1eSkgKiAocG9pbnQueSAtIHV5KVxuICBcbiAgcmV0dXJuIGRpc3RTcSA8PSByYWRpdXNTcVxufVxuXG5mdW5jdGlvbiBoYXNFZGdlKHRyaWFuZ2xlOiBUcmlhbmdsZSwgZWRnZTogeyBwMTogUG9pbnQ7IHAyOiBQb2ludCB9KTogYm9vbGVhbiB7XG4gIGNvbnN0IHBvaW50cyA9IFt0cmlhbmdsZS5wMSwgdHJpYW5nbGUucDIsIHRyaWFuZ2xlLnAzXVxuICBsZXQgaGFzUDEgPSBmYWxzZVxuICBsZXQgaGFzUDIgPSBmYWxzZVxuICBcbiAgZm9yIChjb25zdCBwIG9mIHBvaW50cykge1xuICAgIGlmIChwLmlkID09PSBlZGdlLnAxLmlkKSBoYXNQMSA9IHRydWVcbiAgICBpZiAocC5pZCA9PT0gZWRnZS5wMi5pZCkgaGFzUDIgPSB0cnVlXG4gIH1cbiAgXG4gIHJldHVybiBoYXNQMSAmJiBoYXNQMlxufVxuXG5leHBvcnQgZnVuY3Rpb24gdXNlSW1hZ2VNZXNoKGNvbmZpZzogSW1hZ2VNZXNoQ29uZmlnKToge1xuICBtZXNoOiBNZXNoXG4gIGlzTG9hZGluZzogYm9vbGVhblxuICBlcnJvcjogc3RyaW5nIHwgbnVsbFxufSB7XG4gIGNvbnN0IHtcbiAgICBpbWFnZVNyYyxcbiAgICB3aWR0aCxcbiAgICBoZWlnaHQsXG4gICAgZWRnZVRocmVzaG9sZCA9IDUwLFxuICAgIHBvaW50RGVuc2l0eSA9IDAuMDgsXG4gICAgbWF4UG9pbnRzID0gNTAwLFxuICB9ID0gY29uZmlnXG5cbiAgY29uc3QgW21lc2gsIHNldE1lc2hdID0gdXNlU3RhdGU8TWVzaD4oeyBwb2ludHM6IFtdLCB0cmlhbmdsZXM6IFtdIH0pXG4gIGNvbnN0IFtpc0xvYWRpbmcsIHNldElzTG9hZGluZ10gPSB1c2VTdGF0ZSh0cnVlKVxuICBjb25zdCBbZXJyb3IsIHNldEVycm9yXSA9IHVzZVN0YXRlPHN0cmluZyB8IG51bGw+KG51bGwpXG5cbiAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICBpZiAoIWltYWdlU3JjKSB7XG4gICAgICBzZXRJc0xvYWRpbmcoZmFsc2UpXG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICBjb25zdCBwcm9jZXNzSW1hZ2UgPSBhc3luYyAoKSA9PiB7XG4gICAgICBzZXRJc0xvYWRpbmcodHJ1ZSlcbiAgICAgIHNldEVycm9yKG51bGwpXG5cbiAgICAgIHRyeSB7XG4gICAgICAgIC8vIENyZWF0ZSBpbWFnZSBlbGVtZW50XG4gICAgICAgIGNvbnN0IGltZyA9IG5ldyBJbWFnZSgpXG4gICAgICAgIC8vIERvbid0IHNldCBjcm9zc09yaWdpbiBmb3IgbG9jYWwgaW1hZ2VzXG4gICAgICAgIGlmIChpbWFnZVNyYy5zdGFydHNXaXRoKCdodHRwJykpIHtcbiAgICAgICAgICBpbWcuY3Jvc3NPcmlnaW4gPSAnYW5vbnltb3VzJ1xuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICBhd2FpdCBuZXcgUHJvbWlzZTx2b2lkPigocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgICAgaW1nLm9ubG9hZCA9ICgpID0+IHtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKCdJbWFnZSBsb2FkZWQgc3VjY2Vzc2Z1bGx5OicsIGltZy53aWR0aCwgaW1nLmhlaWdodClcbiAgICAgICAgICAgIHJlc29sdmUoKVxuICAgICAgICAgIH1cbiAgICAgICAgICBpbWcub25lcnJvciA9IChlKSA9PiB7XG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKCdJbWFnZSBsb2FkIGVycm9yOicsIGUpXG4gICAgICAgICAgICByZWplY3QobmV3IEVycm9yKCdGYWlsZWQgdG8gbG9hZCBpbWFnZScpKVxuICAgICAgICAgIH1cbiAgICAgICAgICBpbWcuc3JjID0gaW1hZ2VTcmNcbiAgICAgICAgfSlcblxuICAgICAgICAvLyBDcmVhdGUgY2FudmFzIGFuZCBkcmF3IGltYWdlXG4gICAgICAgIGNvbnN0IGNhbnZhcyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2NhbnZhcycpXG4gICAgICAgIGNhbnZhcy53aWR0aCA9IHdpZHRoXG4gICAgICAgIGNhbnZhcy5oZWlnaHQgPSBoZWlnaHRcbiAgICAgICAgY29uc3QgY3R4ID0gY2FudmFzLmdldENvbnRleHQoJzJkJylcbiAgICAgICAgXG4gICAgICAgIGlmICghY3R4KSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdDb3VsZCBub3QgZ2V0IGNhbnZhcyBjb250ZXh0JylcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIERyYXcgaW1hZ2Ugc2NhbGVkIHRvIGNhbnZhcyBzaXplXG4gICAgICAgIGN0eC5kcmF3SW1hZ2UoaW1nLCAwLCAwLCB3aWR0aCwgaGVpZ2h0KVxuICAgICAgICBcbiAgICAgICAgLy8gR2V0IGltYWdlIGRhdGFcbiAgICAgICAgY29uc3QgaW1hZ2VEYXRhID0gY3R4LmdldEltYWdlRGF0YSgwLCAwLCB3aWR0aCwgaGVpZ2h0KVxuICAgICAgICBcbiAgICAgICAgLy8gRGV0ZWN0IGVkZ2VzXG4gICAgICAgIGNvbnN0IGVkZ2VzID0gZGV0ZWN0RWRnZXMoaW1hZ2VEYXRhKVxuICAgICAgICBjb25zb2xlLmxvZygnRWRnZXMgZGV0ZWN0ZWQsIG1heCB2YWx1ZTonLCBNYXRoLm1heCguLi5lZGdlcykpXG4gICAgICAgIFxuICAgICAgICAvLyBTYW1wbGUgcG9pbnRzIGFsb25nIGVkZ2VzXG4gICAgICAgIGNvbnN0IHBvaW50cyA9IHNhbXBsZUVkZ2VQb2ludHMoXG4gICAgICAgICAgZWRnZXMsXG4gICAgICAgICAgd2lkdGgsXG4gICAgICAgICAgaGVpZ2h0LFxuICAgICAgICAgIGVkZ2VUaHJlc2hvbGQsXG4gICAgICAgICAgcG9pbnREZW5zaXR5LFxuICAgICAgICAgIG1heFBvaW50c1xuICAgICAgICApXG4gICAgICAgIGNvbnNvbGUubG9nKCdQb2ludHMgc2FtcGxlZDonLCBwb2ludHMubGVuZ3RoKVxuICAgICAgICBcbiAgICAgICAgLy8gQ3JlYXRlIHRyaWFuZ2xlcyB1c2luZyBEZWxhdW5heSB0cmlhbmd1bGF0aW9uXG4gICAgICAgIGNvbnN0IHRyaWFuZ2xlcyA9IGRlbGF1bmF5VHJpYW5ndWxhdGUocG9pbnRzLCB3aWR0aCwgaGVpZ2h0KVxuICAgICAgICBjb25zb2xlLmxvZygnVHJpYW5nbGVzIGNyZWF0ZWQ6JywgdHJpYW5nbGVzLmxlbmd0aClcbiAgICAgICAgXG4gICAgICAgIHNldE1lc2goeyBwb2ludHMsIHRyaWFuZ2xlcyB9KVxuICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoJ3VzZUltYWdlTWVzaCBlcnJvcjonLCBlcnIpXG4gICAgICAgIHNldEVycm9yKGVyciBpbnN0YW5jZW9mIEVycm9yID8gZXJyLm1lc3NhZ2UgOiAnVW5rbm93biBlcnJvcicpXG4gICAgICAgIC8vIEZhbGxiYWNrIHRvIGVtcHR5IG1lc2hcbiAgICAgICAgc2V0TWVzaCh7IHBvaW50czogW10sIHRyaWFuZ2xlczogW10gfSlcbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIHNldElzTG9hZGluZyhmYWxzZSlcbiAgICAgIH1cbiAgICB9XG5cbiAgICBwcm9jZXNzSW1hZ2UoKVxuICB9LCBbaW1hZ2VTcmMsIHdpZHRoLCBoZWlnaHQsIGVkZ2VUaHJlc2hvbGQsIHBvaW50RGVuc2l0eSwgbWF4UG9pbnRzXSlcblxuICByZXR1cm4geyBtZXNoLCBpc0xvYWRpbmcsIGVycm9yIH1cbn1cbiJdLCJuYW1lcyI6WyJ1c2VTdGF0ZSIsInVzZUVmZmVjdCIsIlNPQkVMX1giLCJTT0JFTF9ZIiwiZ2V0UGl4ZWxHcmF5c2NhbGUiLCJpbWFnZURhdGEiLCJ4IiwieSIsImlkeCIsIndpZHRoIiwiciIsImRhdGEiLCJnIiwiYiIsImFwcGx5S2VybmVsIiwia2VybmVsIiwic3VtIiwia3kiLCJreCIsInB4IiwiTWF0aCIsIm1pbiIsIm1heCIsInB5IiwiaGVpZ2h0IiwiZ3JheSIsImRldGVjdEVkZ2VzIiwiZWRnZXMiLCJGbG9hdDMyQXJyYXkiLCJneCIsImd5IiwibWFnbml0dWRlIiwic3FydCIsInNhbXBsZUVkZ2VQb2ludHMiLCJ0aHJlc2hvbGQiLCJkZW5zaXR5IiwibWF4UG9pbnRzIiwicG9pbnRzIiwic3RlcCIsImZsb29yIiwiZWRnZVZhbHVlIiwiaml0dGVyWCIsInJhbmRvbSIsImppdHRlclkiLCJwdXNoIiwiaWQiLCJsZW5ndGgiLCJib3VuZGFyeVN0ZXAiLCJib3VuZGFyeUNvdW50IiwiZWRnZVBvaW50cyIsInNsaWNlIiwiYm91bmRhcnlQb2ludHMiLCJzYW1wbGVkRWRnZSIsInNvcnQiLCJtYXAiLCJwIiwiaSIsImRlbGF1bmF5VHJpYW5ndWxhdGUiLCJtYXJnaW4iLCJzdXBlclBvaW50cyIsInRyaWFuZ2xlcyIsInAxIiwicDIiLCJwMyIsInBvaW50IiwiYmFkVHJpYW5nbGVzIiwidHJpYW5nbGUiLCJpc1BvaW50SW5DaXJjdW1jaXJjbGUiLCJwb2x5Z29uIiwiZWRnZSIsImlzU2hhcmVkIiwib3RoZXIiLCJoYXNFZGdlIiwiZmlsdGVyIiwidCIsImluY2x1ZGVzIiwiZCIsImFicyIsInV4IiwidXkiLCJyYWRpdXNTcSIsImRpc3RTcSIsImhhc1AxIiwiaGFzUDIiLCJ1c2VJbWFnZU1lc2giLCJjb25maWciLCJpbWFnZVNyYyIsImVkZ2VUaHJlc2hvbGQiLCJwb2ludERlbnNpdHkiLCJtZXNoIiwic2V0TWVzaCIsImlzTG9hZGluZyIsInNldElzTG9hZGluZyIsImVycm9yIiwic2V0RXJyb3IiLCJwcm9jZXNzSW1hZ2UiLCJpbWciLCJJbWFnZSIsInN0YXJ0c1dpdGgiLCJjcm9zc09yaWdpbiIsIlByb21pc2UiLCJyZXNvbHZlIiwicmVqZWN0Iiwib25sb2FkIiwiY29uc29sZSIsImxvZyIsIm9uZXJyb3IiLCJlIiwiRXJyb3IiLCJzcmMiLCJjYW52YXMiLCJkb2N1bWVudCIsImNyZWF0ZUVsZW1lbnQiLCJjdHgiLCJnZXRDb250ZXh0IiwiZHJhd0ltYWdlIiwiZ2V0SW1hZ2VEYXRhIiwiZXJyIiwibWVzc2FnZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./components/portrait/useImageMesh.ts\n"));

/***/ })

});