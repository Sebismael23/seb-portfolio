"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/page",{

/***/ "(app-pages-browser)/./components/portrait/useImageMesh.ts":
/*!*********************************************!*\
  !*** ./components/portrait/useImageMesh.ts ***!
  \*********************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   useImageMesh: function() { return /* binding */ useImageMesh; }\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);\n/* __next_internal_client_entry_do_not_use__ useImageMesh auto */ \n// Sobel edge detection kernels\nconst SOBEL_X = [\n    [\n        -1,\n        0,\n        1\n    ],\n    [\n        -2,\n        0,\n        2\n    ],\n    [\n        -1,\n        0,\n        1\n    ]\n];\nconst SOBEL_Y = [\n    [\n        -1,\n        -2,\n        -1\n    ],\n    [\n        0,\n        0,\n        0\n    ],\n    [\n        1,\n        2,\n        1\n    ]\n];\nfunction getPixelGrayscale(imageData, x, y) {\n    const idx = (y * imageData.width + x) * 4;\n    const r = imageData.data[idx];\n    const g = imageData.data[idx + 1];\n    const b = imageData.data[idx + 2];\n    // Luminance formula\n    return 0.299 * r + 0.587 * g + 0.114 * b;\n}\nfunction applyKernel(imageData, x, y, kernel) {\n    let sum = 0;\n    for(let ky = -1; ky <= 1; ky++){\n        for(let kx = -1; kx <= 1; kx++){\n            const px = Math.min(Math.max(x + kx, 0), imageData.width - 1);\n            const py = Math.min(Math.max(y + ky, 0), imageData.height - 1);\n            const gray = getPixelGrayscale(imageData, px, py);\n            sum += gray * kernel[ky + 1][kx + 1];\n        }\n    }\n    return sum;\n}\nfunction detectEdges(imageData) {\n    const edges = new Float32Array(imageData.width * imageData.height);\n    for(let y = 1; y < imageData.height - 1; y++){\n        for(let x = 1; x < imageData.width - 1; x++){\n            const gx = applyKernel(imageData, x, y, SOBEL_X);\n            const gy = applyKernel(imageData, x, y, SOBEL_Y);\n            const magnitude = Math.sqrt(gx * gx + gy * gy);\n            edges[y * imageData.width + x] = magnitude;\n        }\n    }\n    return edges;\n}\nfunction sampleEdgePoints(edges, width, height, threshold, density, maxPoints) {\n    const points = [];\n    const step = Math.max(1, Math.floor(1 / density));\n    // Sample points along edges\n    for(let y = step; y < height - step; y += step){\n        for(let x = step; x < width - step; x += step){\n            const edgeValue = edges[y * width + x];\n            if (edgeValue > threshold) {\n                // Add some jitter for more organic look\n                const jitterX = (Math.random() - 0.5) * step * 0.5;\n                const jitterY = (Math.random() - 0.5) * step * 0.5;\n                points.push({\n                    x: x + jitterX,\n                    y: y + jitterY,\n                    id: points.length\n                });\n            }\n        }\n    }\n    // Add boundary points for better triangulation\n    const boundaryStep = Math.max(20, width / 15);\n    for(let x = 0; x <= width; x += boundaryStep){\n        points.push({\n            x,\n            y: 0,\n            id: points.length\n        });\n        points.push({\n            x,\n            y: height,\n            id: points.length\n        });\n    }\n    for(let y = boundaryStep; y < height; y += boundaryStep){\n        points.push({\n            x: 0,\n            y,\n            id: points.length\n        });\n        points.push({\n            x: width,\n            y,\n            id: points.length\n        });\n    }\n    // Add corner points\n    points.push({\n        x: 0,\n        y: 0,\n        id: points.length\n    });\n    points.push({\n        x: width,\n        y: 0,\n        id: points.length\n    });\n    points.push({\n        x: 0,\n        y: height,\n        id: points.length\n    });\n    points.push({\n        x: width,\n        y: height,\n        id: points.length\n    });\n    // Limit points if too many\n    if (points.length > maxPoints) {\n        // Keep boundary points and randomly sample edge points\n        const boundaryCount = Math.floor(width / boundaryStep) * 2 + Math.floor(height / boundaryStep) * 2 + 4;\n        const edgePoints = points.slice(0, points.length - boundaryCount);\n        const boundaryPoints = points.slice(points.length - boundaryCount);\n        // Randomly sample edge points\n        const sampledEdge = edgePoints.sort(()=>Math.random() - 0.5).slice(0, maxPoints - boundaryCount);\n        return [\n            ...sampledEdge,\n            ...boundaryPoints\n        ].map((p, i)=>({\n                ...p,\n                id: i\n            }));\n    }\n    return points;\n}\n// Delaunay triangulation using Bowyer-Watson algorithm\nfunction delaunayTriangulate(points, width, height) {\n    if (points.length < 3) return [];\n    // Create super triangle that contains all points\n    const margin = Math.max(width, height) * 2;\n    const superTriangle = {\n        p1: {\n            x: width / 2,\n            y: -margin,\n            id: -1\n        },\n        p2: {\n            x: -margin,\n            y: height + margin,\n            id: -2\n        },\n        p3: {\n            x: width + margin,\n            y: height + margin,\n            id: -3\n        }\n    };\n    let triangles = [\n        superTriangle\n    ];\n    // Add points one at a time\n    for (const point of points){\n        const badTriangles = [];\n        // Find all triangles whose circumcircle contains the point\n        for (const triangle of triangles){\n            if (isPointInCircumcircle(point, triangle)) {\n                badTriangles.push(triangle);\n            }\n        }\n        // Find the boundary of the polygonal hole\n        const polygon = [];\n        for (const triangle of badTriangles){\n            const edges = [\n                {\n                    p1: triangle.p1,\n                    p2: triangle.p2\n                },\n                {\n                    p1: triangle.p2,\n                    p2: triangle.p3\n                },\n                {\n                    p1: triangle.p3,\n                    p2: triangle.p1\n                }\n            ];\n            for (const edge of edges){\n                // Check if edge is shared with another bad triangle\n                let isShared = false;\n                for (const other of badTriangles){\n                    if (other === triangle) continue;\n                    if (hasEdge(other, edge)) {\n                        isShared = true;\n                        break;\n                    }\n                }\n                if (!isShared) {\n                    polygon.push(edge);\n                }\n            }\n        }\n        // Remove bad triangles\n        triangles = triangles.filter((t)=>!badTriangles.includes(t));\n        // Create new triangles from polygon edges to point\n        for (const edge of polygon){\n            triangles.push({\n                p1: edge.p1,\n                p2: edge.p2,\n                p3: point\n            });\n        }\n    }\n    // Remove triangles that share vertices with super triangle\n    triangles = triangles.filter((t)=>t.p1.id >= 0 && t.p2.id >= 0 && t.p3.id >= 0);\n    return triangles;\n}\nfunction isPointInCircumcircle(point, triangle) {\n    const { p1, p2, p3 } = triangle;\n    const ax = p1.x - point.x;\n    const ay = p1.y - point.y;\n    const bx = p2.x - point.x;\n    const by = p2.y - point.y;\n    const cx = p3.x - point.x;\n    const cy = p3.y - point.y;\n    const det = (ax * ax + ay * ay) * (bx * cy - cx * by) - (bx * bx + by * by) * (ax * cy - cx * ay) + (cx * cx + cy * cy) * (ax * by - bx * ay);\n    return det > 0;\n}\nfunction hasEdge(triangle, edge) {\n    const points = [\n        triangle.p1,\n        triangle.p2,\n        triangle.p3\n    ];\n    let hasP1 = false;\n    let hasP2 = false;\n    for (const p of points){\n        if (p.id === edge.p1.id) hasP1 = true;\n        if (p.id === edge.p2.id) hasP2 = true;\n    }\n    return hasP1 && hasP2;\n}\nfunction useImageMesh(config) {\n    const { imageSrc, width, height, edgeThreshold = 50, pointDensity = 0.08, maxPoints = 500 } = config;\n    const [mesh, setMesh] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)({\n        points: [],\n        triangles: []\n    });\n    const [isLoading, setIsLoading] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(true);\n    const [error, setError] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(null);\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        if (!imageSrc) {\n            setIsLoading(false);\n            return;\n        }\n        const processImage = async ()=>{\n            setIsLoading(true);\n            setError(null);\n            try {\n                // Create image element\n                const img = new Image();\n                // Don't set crossOrigin for local images\n                if (imageSrc.startsWith(\"http\")) {\n                    img.crossOrigin = \"anonymous\";\n                }\n                await new Promise((resolve, reject)=>{\n                    img.onload = ()=>{\n                        console.log(\"Image loaded successfully:\", img.width, img.height);\n                        resolve();\n                    };\n                    img.onerror = (e)=>{\n                        console.error(\"Image load error:\", e);\n                        reject(new Error(\"Failed to load image\"));\n                    };\n                    img.src = imageSrc;\n                });\n                // Create canvas and draw image\n                const canvas = document.createElement(\"canvas\");\n                canvas.width = width;\n                canvas.height = height;\n                const ctx = canvas.getContext(\"2d\");\n                if (!ctx) {\n                    throw new Error(\"Could not get canvas context\");\n                }\n                // Draw image scaled to canvas size\n                ctx.drawImage(img, 0, 0, width, height);\n                // Get image data\n                const imageData = ctx.getImageData(0, 0, width, height);\n                // Detect edges\n                const edges = detectEdges(imageData);\n                console.log(\"Edges detected, max value:\", Math.max(...edges));\n                // Sample points along edges\n                const points = sampleEdgePoints(edges, width, height, edgeThreshold, pointDensity, maxPoints);\n                console.log(\"Points sampled:\", points.length);\n                // Create triangles using Delaunay triangulation\n                const triangles = delaunayTriangulate(points, width, height);\n                console.log(\"Triangles created:\", triangles.length);\n                setMesh({\n                    points,\n                    triangles\n                });\n            } catch (err) {\n                console.error(\"useImageMesh error:\", err);\n                setError(err instanceof Error ? err.message : \"Unknown error\");\n                // Fallback to empty mesh\n                setMesh({\n                    points: [],\n                    triangles: []\n                });\n            } finally{\n                setIsLoading(false);\n            }\n        };\n        processImage();\n    }, [\n        imageSrc,\n        width,\n        height,\n        edgeThreshold,\n        pointDensity,\n        maxPoints\n    ]);\n    return {\n        mesh,\n        isLoading,\n        error\n    };\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL2NvbXBvbmVudHMvcG9ydHJhaXQvdXNlSW1hZ2VNZXNoLnRzIiwibWFwcGluZ3MiOiI7Ozs7OztrRUFFMkM7QUFZM0MsK0JBQStCO0FBQy9CLE1BQU1FLFVBQVU7SUFDZDtRQUFDLENBQUM7UUFBRztRQUFHO0tBQUU7SUFDVjtRQUFDLENBQUM7UUFBRztRQUFHO0tBQUU7SUFDVjtRQUFDLENBQUM7UUFBRztRQUFHO0tBQUU7Q0FDWDtBQUVELE1BQU1DLFVBQVU7SUFDZDtRQUFDLENBQUM7UUFBRyxDQUFDO1FBQUcsQ0FBQztLQUFFO0lBQ1o7UUFBQztRQUFHO1FBQUc7S0FBRTtJQUNUO1FBQUM7UUFBRztRQUFHO0tBQUU7Q0FDVjtBQUVELFNBQVNDLGtCQUNQQyxTQUFvQixFQUNwQkMsQ0FBUyxFQUNUQyxDQUFTO0lBRVQsTUFBTUMsTUFBTSxDQUFDRCxJQUFJRixVQUFVSSxLQUFLLEdBQUdILENBQUFBLElBQUs7SUFDeEMsTUFBTUksSUFBSUwsVUFBVU0sSUFBSSxDQUFDSCxJQUFJO0lBQzdCLE1BQU1JLElBQUlQLFVBQVVNLElBQUksQ0FBQ0gsTUFBTSxFQUFFO0lBQ2pDLE1BQU1LLElBQUlSLFVBQVVNLElBQUksQ0FBQ0gsTUFBTSxFQUFFO0lBQ2pDLG9CQUFvQjtJQUNwQixPQUFPLFFBQVFFLElBQUksUUFBUUUsSUFBSSxRQUFRQztBQUN6QztBQUVBLFNBQVNDLFlBQ1BULFNBQW9CLEVBQ3BCQyxDQUFTLEVBQ1RDLENBQVMsRUFDVFEsTUFBa0I7SUFFbEIsSUFBSUMsTUFBTTtJQUNWLElBQUssSUFBSUMsS0FBSyxDQUFDLEdBQUdBLE1BQU0sR0FBR0EsS0FBTTtRQUMvQixJQUFLLElBQUlDLEtBQUssQ0FBQyxHQUFHQSxNQUFNLEdBQUdBLEtBQU07WUFDL0IsTUFBTUMsS0FBS0MsS0FBS0MsR0FBRyxDQUFDRCxLQUFLRSxHQUFHLENBQUNoQixJQUFJWSxJQUFJLElBQUliLFVBQVVJLEtBQUssR0FBRztZQUMzRCxNQUFN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R0FBRyxDQUFDLG1CQUFtQnJFLE9BQU9TLE1BQU07Z0JBRTVDLGdEQUFnRDtnQkFDaEQsTUFBTWlCLFlBQVlOLG9CQUFvQnBCLFFBQVE1QixPQUFPZTtnQkFDckRpRixRQUFRQyxHQUFHLENBQUMsc0JBQXNCM0MsVUFBVWpCLE1BQU07Z0JBRWxENkMsUUFBUTtvQkFBRXREO29CQUFRMEI7Z0JBQVU7WUFDOUIsRUFBRSxPQUFPdUQsS0FBSztnQkFDWmIsUUFBUVgsS0FBSyxDQUFDLHVCQUF1QndCO2dCQUNyQ3ZCLFNBQVN1QixlQUFlVCxRQUFRUyxJQUFJQyxPQUFPLEdBQUc7Z0JBQzlDLHlCQUF5QjtnQkFDekI1QixRQUFRO29CQUFFdEQsUUFBUSxFQUFFO29CQUFFMEIsV0FBVyxFQUFFO2dCQUFDO1lBQ3RDLFNBQVU7Z0JBQ1I4QixhQUFhO1lBQ2Y7UUFDRjtRQUVBRztJQUNGLEdBQUc7UUFBQ1Q7UUFBVTlFO1FBQU9lO1FBQVFnRTtRQUFlQztRQUFjckQ7S0FBVTtJQUVwRSxPQUFPO1FBQUVzRDtRQUFNRTtRQUFXRTtJQUFNO0FBQ2xDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL2NvbXBvbmVudHMvcG9ydHJhaXQvdXNlSW1hZ2VNZXNoLnRzPzkwZDkiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBjbGllbnQnXG5cbmltcG9ydCB7IHVzZVN0YXRlLCB1c2VFZmZlY3QgfSBmcm9tICdyZWFjdCdcbmltcG9ydCB0eXBlIHsgTWVzaCwgUG9pbnQsIFRyaWFuZ2xlIH0gZnJvbSAnLi90eXBlcydcblxuaW50ZXJmYWNlIEltYWdlTWVzaENvbmZpZyB7XG4gIGltYWdlU3JjOiBzdHJpbmdcbiAgd2lkdGg6IG51bWJlclxuICBoZWlnaHQ6IG51bWJlclxuICBlZGdlVGhyZXNob2xkPzogbnVtYmVyXG4gIHBvaW50RGVuc2l0eT86IG51bWJlclxuICBtYXhQb2ludHM/OiBudW1iZXJcbn1cblxuLy8gU29iZWwgZWRnZSBkZXRlY3Rpb24ga2VybmVsc1xuY29uc3QgU09CRUxfWCA9IFtcbiAgWy0xLCAwLCAxXSxcbiAgWy0yLCAwLCAyXSxcbiAgWy0xLCAwLCAxXSxcbl1cblxuY29uc3QgU09CRUxfWSA9IFtcbiAgWy0xLCAtMiwgLTFdLFxuICBbMCwgMCwgMF0sXG4gIFsxLCAyLCAxXSxcbl1cblxuZnVuY3Rpb24gZ2V0UGl4ZWxHcmF5c2NhbGUoXG4gIGltYWdlRGF0YTogSW1hZ2VEYXRhLFxuICB4OiBudW1iZXIsXG4gIHk6IG51bWJlclxuKTogbnVtYmVyIHtcbiAgY29uc3QgaWR4ID0gKHkgKiBpbWFnZURhdGEud2lkdGggKyB4KSAqIDRcbiAgY29uc3QgciA9IGltYWdlRGF0YS5kYXRhW2lkeF1cbiAgY29uc3QgZyA9IGltYWdlRGF0YS5kYXRhW2lkeCArIDFdXG4gIGNvbnN0IGIgPSBpbWFnZURhdGEuZGF0YVtpZHggKyAyXVxuICAvLyBMdW1pbmFuY2UgZm9ybXVsYVxuICByZXR1cm4gMC4yOTkgKiByICsgMC41ODcgKiBnICsgMC4xMTQgKiBiXG59XG5cbmZ1bmN0aW9uIGFwcGx5S2VybmVsKFxuICBpbWFnZURhdGE6IEltYWdlRGF0YSxcbiAgeDogbnVtYmVyLFxuICB5OiBudW1iZXIsXG4gIGtlcm5lbDogbnVtYmVyW11bXVxuKTogbnVtYmVyIHtcbiAgbGV0IHN1bSA9IDBcbiAgZm9yIChsZXQga3kgPSAtMTsga3kgPD0gMTsga3krKykge1xuICAgIGZvciAobGV0IGt4ID0gLTE7IGt4IDw9IDE7IGt4KyspIHtcbiAgICAgIGNvbnN0IHB4ID0gTWF0aC5taW4oTWF0aC5tYXgoeCArIGt4LCAwKSwgaW1hZ2VEYXRhLndpZHRoIC0gMSlcbiAgICAgIGNvbnN0IHB5ID0gTWF0aC5taW4oTWF0aC5tYXgoeSArIGt5LCAwKSwgaW1hZ2VEYXRhLmhlaWdodCAtIDEpXG4gICAgICBjb25zdCBncmF5ID0gZ2V0UGl4ZWxHcmF5c2NhbGUoaW1hZ2VEYXRhLCBweCwgcHkpXG4gICAgICBzdW0gKz0gZ3JheSAqIGtlcm5lbFtreSArIDFdW2t4ICsgMV1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIHN1bVxufVxuXG5mdW5jdGlvbiBkZXRlY3RFZGdlcyhpbWFnZURhdGE6IEltYWdlRGF0YSk6IEZsb2F0MzJBcnJheSB7XG4gIGNvbnN0IGVkZ2VzID0gbmV3IEZsb2F0MzJBcnJheShpbWFnZURhdGEud2lkdGggKiBpbWFnZURhdGEuaGVpZ2h0KVxuICBcbiAgZm9yIChsZXQgeSA9IDE7IHkgPCBpbWFnZURhdGEuaGVpZ2h0IC0gMTsgeSsrKSB7XG4gICAgZm9yIChsZXQgeCA9IDE7IHggPCBpbWFnZURhdGEud2lkdGggLSAxOyB4KyspIHtcbiAgICAgIGNvbnN0IGd4ID0gYXBwbHlLZXJuZWwoaW1hZ2VEYXRhLCB4LCB5LCBTT0JFTF9YKVxuICAgICAgY29uc3QgZ3kgPSBhcHBseUtlcm5lbChpbWFnZURhdGEsIHgsIHksIFNPQkVMX1kpXG4gICAgICBjb25zdCBtYWduaXR1ZGUgPSBNYXRoLnNxcnQoZ3ggKiBneCArIGd5ICogZ3kpXG4gICAgICBlZGdlc1t5ICogaW1hZ2VEYXRhLndpZHRoICsgeF0gPSBtYWduaXR1ZGVcbiAgICB9XG4gIH1cbiAgXG4gIHJldHVybiBlZGdlc1xufVxuXG5mdW5jdGlvbiBzYW1wbGVFZGdlUG9pbnRzKFxuICBlZGdlczogRmxvYXQzMkFycmF5LFxuICB3aWR0aDogbnVtYmVyLFxuICBoZWlnaHQ6IG51bWJlcixcbiAgdGhyZXNob2xkOiBudW1iZXIsXG4gIGRlbnNpdHk6IG51bWJlcixcbiAgbWF4UG9pbnRzOiBudW1iZXJcbik6IFBvaW50W10ge1xuICBjb25zdCBwb2ludHM6IFBvaW50W10gPSBbXVxuICBjb25zdCBzdGVwID0gTWF0aC5tYXgoMSwgTWF0aC5mbG9vcigxIC8gZGVuc2l0eSkpXG4gIFxuICAvLyBTYW1wbGUgcG9pbnRzIGFsb25nIGVkZ2VzXG4gIGZvciAobGV0IHkgPSBzdGVwOyB5IDwgaGVpZ2h0IC0gc3RlcDsgeSArPSBzdGVwKSB7XG4gICAgZm9yIChsZXQgeCA9IHN0ZXA7IHggPCB3aWR0aCAtIHN0ZXA7IHggKz0gc3RlcCkge1xuICAgICAgY29uc3QgZWRnZVZhbHVlID0gZWRnZXNbeSAqIHdpZHRoICsgeF1cbiAgICAgIGlmIChlZGdlVmFsdWUgPiB0aHJlc2hvbGQpIHtcbiAgICAgICAgLy8gQWRkIHNvbWUgaml0dGVyIGZvciBtb3JlIG9yZ2FuaWMgbG9va1xuICAgICAgICBjb25zdCBqaXR0ZXJYID0gKE1hdGgucmFuZG9tKCkgLSAwLjUpICogc3RlcCAqIDAuNVxuICAgICAgICBjb25zdCBqaXR0ZXJZID0gKE1hdGgucmFuZG9tKCkgLSAwLjUpICogc3RlcCAqIDAuNVxuICAgICAgICBwb2ludHMucHVzaCh7XG4gICAgICAgICAgeDogeCArIGppdHRlclgsXG4gICAgICAgICAgeTogeSArIGppdHRlclksXG4gICAgICAgICAgaWQ6IHBvaW50cy5sZW5ndGgsXG4gICAgICAgIH0pXG4gICAgICB9XG4gICAgfVxuICB9XG4gIFxuICAvLyBBZGQgYm91bmRhcnkgcG9pbnRzIGZvciBiZXR0ZXIgdHJpYW5ndWxhdGlvblxuICBjb25zdCBib3VuZGFyeVN0ZXAgPSBNYXRoLm1heCgyMCwgd2lkdGggLyAxNSlcbiAgZm9yIChsZXQgeCA9IDA7IHggPD0gd2lkdGg7IHggKz0gYm91bmRhcnlTdGVwKSB7XG4gICAgcG9pbnRzLnB1c2goeyB4LCB5OiAwLCBpZDogcG9pbnRzLmxlbmd0aCB9KVxuICAgIHBvaW50cy5wdXNoKHsgeCwgeTogaGVpZ2h0LCBpZDogcG9pbnRzLmxlbmd0aCB9KVxuICB9XG4gIGZvciAobGV0IHkgPSBib3VuZGFyeVN0ZXA7IHkgPCBoZWlnaHQ7IHkgKz0gYm91bmRhcnlTdGVwKSB7XG4gICAgcG9pbnRzLnB1c2goeyB4OiAwLCB5LCBpZDogcG9pbnRzLmxlbmd0aCB9KVxuICAgIHBvaW50cy5wdXNoKHsgeDogd2lkdGgsIHksIGlkOiBwb2ludHMubGVuZ3RoIH0pXG4gIH1cbiAgXG4gIC8vIEFkZCBjb3JuZXIgcG9pbnRzXG4gIHBvaW50cy5wdXNoKHsgeDogMCwgeTogMCwgaWQ6IHBvaW50cy5sZW5ndGggfSlcbiAgcG9pbnRzLnB1c2goeyB4OiB3aWR0aCwgeTogMCwgaWQ6IHBvaW50cy5sZW5ndGggfSlcbiAgcG9pbnRzLnB1c2goeyB4OiAwLCB5OiBoZWlnaHQsIGlkOiBwb2ludHMubGVuZ3RoIH0pXG4gIHBvaW50cy5wdXNoKHsgeDogd2lkdGgsIHk6IGhlaWdodCwgaWQ6IHBvaW50cy5sZW5ndGggfSlcbiAgXG4gIC8vIExpbWl0IHBvaW50cyBpZiB0b28gbWFueVxuICBpZiAocG9pbnRzLmxlbmd0aCA+IG1heFBvaW50cykge1xuICAgIC8vIEtlZXAgYm91bmRhcnkgcG9pbnRzIGFuZCByYW5kb21seSBzYW1wbGUgZWRnZSBwb2ludHNcbiAgICBjb25zdCBib3VuZGFyeUNvdW50ID0gTWF0aC5mbG9vcih3aWR0aCAvIGJvdW5kYXJ5U3RlcCkgKiAyICsgTWF0aC5mbG9vcihoZWlnaHQgLyBib3VuZGFyeVN0ZXApICogMiArIDRcbiAgICBjb25zdCBlZGdlUG9pbnRzID0gcG9pbnRzLnNsaWNlKDAsIHBvaW50cy5sZW5ndGggLSBib3VuZGFyeUNvdW50KVxuICAgIGNvbnN0IGJvdW5kYXJ5UG9pbnRzID0gcG9pbnRzLnNsaWNlKHBvaW50cy5sZW5ndGggLSBib3VuZGFyeUNvdW50KVxuICAgIFxuICAgIC8vIFJhbmRvbWx5IHNhbXBsZSBlZGdlIHBvaW50c1xuICAgIGNvbnN0IHNhbXBsZWRFZGdlID0gZWRnZVBvaW50c1xuICAgICAgLnNvcnQoKCkgPT4gTWF0aC5yYW5kb20oKSAtIDAuNSlcbiAgICAgIC5zbGljZSgwLCBtYXhQb2ludHMgLSBib3VuZGFyeUNvdW50KVxuICAgIFxuICAgIHJldHVybiBbLi4uc2FtcGxlZEVkZ2UsIC4uLmJvdW5kYXJ5UG9pbnRzXS5tYXAoKHAsIGkpID0+ICh7IC4uLnAsIGlkOiBpIH0pKVxuICB9XG4gIFxuICByZXR1cm4gcG9pbnRzXG59XG5cbi8vIERlbGF1bmF5IHRyaWFuZ3VsYXRpb24gdXNpbmcgQm93eWVyLVdhdHNvbiBhbGdvcml0aG1cbmZ1bmN0aW9uIGRlbGF1bmF5VHJpYW5ndWxhdGUocG9pbnRzOiBQb2ludFtdLCB3aWR0aDogbnVtYmVyLCBoZWlnaHQ6IG51bWJlcik6IFRyaWFuZ2xlW10ge1xuICBpZiAocG9pbnRzLmxlbmd0aCA8IDMpIHJldHVybiBbXVxuICBcbiAgLy8gQ3JlYXRlIHN1cGVyIHRyaWFuZ2xlIHRoYXQgY29udGFpbnMgYWxsIHBvaW50c1xuICBjb25zdCBtYXJnaW4gPSBNYXRoLm1heCh3aWR0aCwgaGVpZ2h0KSAqIDJcbiAgY29uc3Qgc3VwZXJUcmlhbmdsZTogVHJpYW5nbGUgPSB7XG4gICAgcDE6IHsgeDogd2lkdGggLyAyLCB5OiAtbWFyZ2luLCBpZDogLTEgfSxcbiAgICBwMjogeyB4OiAtbWFyZ2luLCB5OiBoZWlnaHQgKyBtYXJnaW4sIGlkOiAtMiB9LFxuICAgIHAzOiB7IHg6IHdpZHRoICsgbWFyZ2luLCB5OiBoZWlnaHQgKyBtYXJnaW4sIGlkOiAtMyB9LFxuICB9XG4gIFxuICBsZXQgdHJpYW5nbGVzOiBUcmlhbmdsZVtdID0gW3N1cGVyVHJpYW5nbGVdXG4gIFxuICAvLyBBZGQgcG9pbnRzIG9uZSBhdCBhIHRpbWVcbiAgZm9yIChjb25zdCBwb2ludCBvZiBwb2ludHMpIHtcbiAgICBjb25zdCBiYWRUcmlhbmdsZXM6IFRyaWFuZ2xlW10gPSBbXVxuICAgIFxuICAgIC8vIEZpbmQgYWxsIHRyaWFuZ2xlcyB3aG9zZSBjaXJjdW1jaXJjbGUgY29udGFpbnMgdGhlIHBvaW50XG4gICAgZm9yIChjb25zdCB0cmlhbmdsZSBvZiB0cmlhbmdsZXMpIHtcbiAgICAgIGlmIChpc1BvaW50SW5DaXJjdW1jaXJjbGUocG9pbnQsIHRyaWFuZ2xlKSkge1xuICAgICAgICBiYWRUcmlhbmdsZXMucHVzaCh0cmlhbmdsZSlcbiAgICAgIH1cbiAgICB9XG4gICAgXG4gICAgLy8gRmluZCB0aGUgYm91bmRhcnkgb2YgdGhlIHBvbHlnb25hbCBob2xlXG4gICAgY29uc3QgcG9seWdvbjogQXJyYXk8eyBwMTogUG9pbnQ7IHAyOiBQb2ludCB9PiA9IFtdXG4gICAgXG4gICAgZm9yIChjb25zdCB0cmlhbmdsZSBvZiBiYWRUcmlhbmdsZXMpIHtcbiAgICAgIGNvbnN0IGVkZ2VzID0gW1xuICAgICAgICB7IHAxOiB0cmlhbmdsZS5wMSwgcDI6IHRyaWFuZ2xlLnAyIH0sXG4gICAgICAgIHsgcDE6IHRyaWFuZ2xlLnAyLCBwMjogdHJpYW5nbGUucDMgfSxcbiAgICAgICAgeyBwMTogdHJpYW5nbGUucDMsIHAyOiB0cmlhbmdsZS5wMSB9LFxuICAgICAgXVxuICAgICAgXG4gICAgICBmb3IgKGNvbnN0IGVkZ2Ugb2YgZWRnZXMpIHtcbiAgICAgICAgLy8gQ2hlY2sgaWYgZWRnZSBpcyBzaGFyZWQgd2l0aCBhbm90aGVyIGJhZCB0cmlhbmdsZVxuICAgICAgICBsZXQgaXNTaGFyZWQgPSBmYWxzZVxuICAgICAgICBmb3IgKGNvbnN0IG90aGVyIG9mIGJhZFRyaWFuZ2xlcykge1xuICAgICAgICAgIGlmIChvdGhlciA9PT0gdHJpYW5nbGUpIGNvbnRpbnVlXG4gICAgICAgICAgaWYgKGhhc0VkZ2Uob3RoZXIsIGVkZ2UpKSB7XG4gICAgICAgICAgICBpc1NoYXJlZCA9IHRydWVcbiAgICAgICAgICAgIGJyZWFrXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICghaXNTaGFyZWQpIHtcbiAgICAgICAgICBwb2x5Z29uLnB1c2goZWRnZSlcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBcbiAgICAvLyBSZW1vdmUgYmFkIHRyaWFuZ2xlc1xuICAgIHRyaWFuZ2xlcyA9IHRyaWFuZ2xlcy5maWx0ZXIoKHQpID0+ICFiYWRUcmlhbmdsZXMuaW5jbHVkZXModCkpXG4gICAgXG4gICAgLy8gQ3JlYXRlIG5ldyB0cmlhbmdsZXMgZnJvbSBwb2x5Z29uIGVkZ2VzIHRvIHBvaW50XG4gICAgZm9yIChjb25zdCBlZGdlIG9mIHBvbHlnb24pIHtcbiAgICAgIHRyaWFuZ2xlcy5wdXNoKHtcbiAgICAgICAgcDE6IGVkZ2UucDEsXG4gICAgICAgIHAyOiBlZGdlLnAyLFxuICAgICAgICBwMzogcG9pbnQsXG4gICAgICB9KVxuICAgIH1cbiAgfVxuICBcbiAgLy8gUmVtb3ZlIHRyaWFuZ2xlcyB0aGF0IHNoYXJlIHZlcnRpY2VzIHdpdGggc3VwZXIgdHJpYW5nbGVcbiAgdHJpYW5nbGVzID0gdHJpYW5nbGVzLmZpbHRlcihcbiAgICAodCkgPT5cbiAgICAgIHQucDEuaWQgPj0gMCAmJlxuICAgICAgdC5wMi5pZCA+PSAwICYmXG4gICAgICB0LnAzLmlkID49IDBcbiAgKVxuICBcbiAgcmV0dXJuIHRyaWFuZ2xlc1xufVxuXG5mdW5jdGlvbiBpc1BvaW50SW5DaXJjdW1jaXJjbGUocG9pbnQ6IFBvaW50LCB0cmlhbmdsZTogVHJpYW5nbGUpOiBib29sZWFuIHtcbiAgY29uc3QgeyBwMSwgcDIsIHAzIH0gPSB0cmlhbmdsZVxuICBcbiAgY29uc3QgYXggPSBwMS54IC0gcG9pbnQueFxuICBjb25zdCBheSA9IHAxLnkgLSBwb2ludC55XG4gIGNvbnN0IGJ4ID0gcDIueCAtIHBvaW50LnhcbiAgY29uc3QgYnkgPSBwMi55IC0gcG9pbnQueVxuICBjb25zdCBjeCA9IHAzLnggLSBwb2ludC54XG4gIGNvbnN0IGN5ID0gcDMueSAtIHBvaW50LnlcbiAgXG4gIGNvbnN0IGRldCA9XG4gICAgKGF4ICogYXggKyBheSAqIGF5KSAqIChieCAqIGN5IC0gY3ggKiBieSkgLVxuICAgIChieCAqIGJ4ICsgYnkgKiBieSkgKiAoYXggKiBjeSAtIGN4ICogYXkpICtcbiAgICAoY3ggKiBjeCArIGN5ICogY3kpICogKGF4ICogYnkgLSBieCAqIGF5KVxuICBcbiAgcmV0dXJuIGRldCA+IDBcbn1cblxuZnVuY3Rpb24gaGFzRWRnZSh0cmlhbmdsZTogVHJpYW5nbGUsIGVkZ2U6IHsgcDE6IFBvaW50OyBwMjogUG9pbnQgfSk6IGJvb2xlYW4ge1xuICBjb25zdCBwb2ludHMgPSBbdHJpYW5nbGUucDEsIHRyaWFuZ2xlLnAyLCB0cmlhbmdsZS5wM11cbiAgbGV0IGhhc1AxID0gZmFsc2VcbiAgbGV0IGhhc1AyID0gZmFsc2VcbiAgXG4gIGZvciAoY29uc3QgcCBvZiBwb2ludHMpIHtcbiAgICBpZiAocC5pZCA9PT0gZWRnZS5wMS5pZCkgaGFzUDEgPSB0cnVlXG4gICAgaWYgKHAuaWQgPT09IGVkZ2UucDIuaWQpIGhhc1AyID0gdHJ1ZVxuICB9XG4gIFxuICByZXR1cm4gaGFzUDEgJiYgaGFzUDJcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHVzZUltYWdlTWVzaChjb25maWc6IEltYWdlTWVzaENvbmZpZyk6IHtcbiAgbWVzaDogTWVzaFxuICBpc0xvYWRpbmc6IGJvb2xlYW5cbiAgZXJyb3I6IHN0cmluZyB8IG51bGxcbn0ge1xuICBjb25zdCB7XG4gICAgaW1hZ2VTcmMsXG4gICAgd2lkdGgsXG4gICAgaGVpZ2h0LFxuICAgIGVkZ2VUaHJlc2hvbGQgPSA1MCxcbiAgICBwb2ludERlbnNpdHkgPSAwLjA4LFxuICAgIG1heFBvaW50cyA9IDUwMCxcbiAgfSA9IGNvbmZpZ1xuXG4gIGNvbnN0IFttZXNoLCBzZXRNZXNoXSA9IHVzZVN0YXRlPE1lc2g+KHsgcG9pbnRzOiBbXSwgdHJpYW5nbGVzOiBbXSB9KVxuICBjb25zdCBbaXNMb2FkaW5nLCBzZXRJc0xvYWRpbmddID0gdXNlU3RhdGUodHJ1ZSlcbiAgY29uc3QgW2Vycm9yLCBzZXRFcnJvcl0gPSB1c2VTdGF0ZTxzdHJpbmcgfCBudWxsPihudWxsKVxuXG4gIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgaWYgKCFpbWFnZVNyYykge1xuICAgICAgc2V0SXNMb2FkaW5nKGZhbHNlKVxuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgY29uc3QgcHJvY2Vzc0ltYWdlID0gYXN5bmMgKCkgPT4ge1xuICAgICAgc2V0SXNMb2FkaW5nKHRydWUpXG4gICAgICBzZXRFcnJvcihudWxsKVxuXG4gICAgICB0cnkge1xuICAgICAgICAvLyBDcmVhdGUgaW1hZ2UgZWxlbWVudFxuICAgICAgICBjb25zdCBpbWcgPSBuZXcgSW1hZ2UoKVxuICAgICAgICAvLyBEb24ndCBzZXQgY3Jvc3NPcmlnaW4gZm9yIGxvY2FsIGltYWdlc1xuICAgICAgICBpZiAoaW1hZ2VTcmMuc3RhcnRzV2l0aCgnaHR0cCcpKSB7XG4gICAgICAgICAgaW1nLmNyb3NzT3JpZ2luID0gJ2Fub255bW91cydcbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgYXdhaXQgbmV3IFByb21pc2U8dm9pZD4oKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICAgIGltZy5vbmxvYWQgPSAoKSA9PiB7XG4gICAgICAgICAgICBjb25zb2xlLmxvZygnSW1hZ2UgbG9hZGVkIHN1Y2Nlc3NmdWxseTonLCBpbWcud2lkdGgsIGltZy5oZWlnaHQpXG4gICAgICAgICAgICByZXNvbHZlKClcbiAgICAgICAgICB9XG4gICAgICAgICAgaW1nLm9uZXJyb3IgPSAoZSkgPT4ge1xuICAgICAgICAgICAgY29uc29sZS5lcnJvcignSW1hZ2UgbG9hZCBlcnJvcjonLCBlKVxuICAgICAgICAgICAgcmVqZWN0KG5ldyBFcnJvcignRmFpbGVkIHRvIGxvYWQgaW1hZ2UnKSlcbiAgICAgICAgICB9XG4gICAgICAgICAgaW1nLnNyYyA9IGltYWdlU3JjXG4gICAgICAgIH0pXG5cbiAgICAgICAgLy8gQ3JlYXRlIGNhbnZhcyBhbmQgZHJhdyBpbWFnZVxuICAgICAgICBjb25zdCBjYW52YXMgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdjYW52YXMnKVxuICAgICAgICBjYW52YXMud2lkdGggPSB3aWR0aFxuICAgICAgICBjYW52YXMuaGVpZ2h0ID0gaGVpZ2h0XG4gICAgICAgIGNvbnN0IGN0eCA9IGNhbnZhcy5nZXRDb250ZXh0KCcyZCcpXG4gICAgICAgIFxuICAgICAgICBpZiAoIWN0eCkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcignQ291bGQgbm90IGdldCBjYW52YXMgY29udGV4dCcpXG4gICAgICAgIH1cblxuICAgICAgICAvLyBEcmF3IGltYWdlIHNjYWxlZCB0byBjYW52YXMgc2l6ZVxuICAgICAgICBjdHguZHJhd0ltYWdlKGltZywgMCwgMCwgd2lkdGgsIGhlaWdodClcbiAgICAgICAgXG4gICAgICAgIC8vIEdldCBpbWFnZSBkYXRhXG4gICAgICAgIGNvbnN0IGltYWdlRGF0YSA9IGN0eC5nZXRJbWFnZURhdGEoMCwgMCwgd2lkdGgsIGhlaWdodClcbiAgICAgICAgXG4gICAgICAgIC8vIERldGVjdCBlZGdlc1xuICAgICAgICBjb25zdCBlZGdlcyA9IGRldGVjdEVkZ2VzKGltYWdlRGF0YSlcbiAgICAgICAgY29uc29sZS5sb2coJ0VkZ2VzIGRldGVjdGVkLCBtYXggdmFsdWU6JywgTWF0aC5tYXgoLi4uZWRnZXMpKVxuICAgICAgICBcbiAgICAgICAgLy8gU2FtcGxlIHBvaW50cyBhbG9uZyBlZGdlc1xuICAgICAgICBjb25zdCBwb2ludHMgPSBzYW1wbGVFZGdlUG9pbnRzKFxuICAgICAgICAgIGVkZ2VzLFxuICAgICAgICAgIHdpZHRoLFxuICAgICAgICAgIGhlaWdodCxcbiAgICAgICAgICBlZGdlVGhyZXNob2xkLFxuICAgICAgICAgIHBvaW50RGVuc2l0eSxcbiAgICAgICAgICBtYXhQb2ludHNcbiAgICAgICAgKVxuICAgICAgICBjb25zb2xlLmxvZygnUG9pbnRzIHNhbXBsZWQ6JywgcG9pbnRzLmxlbmd0aClcbiAgICAgICAgXG4gICAgICAgIC8vIENyZWF0ZSB0cmlhbmdsZXMgdXNpbmcgRGVsYXVuYXkgdHJpYW5ndWxhdGlvblxuICAgICAgICBjb25zdCB0cmlhbmdsZXMgPSBkZWxhdW5heVRyaWFuZ3VsYXRlKHBvaW50cywgd2lkdGgsIGhlaWdodClcbiAgICAgICAgY29uc29sZS5sb2coJ1RyaWFuZ2xlcyBjcmVhdGVkOicsIHRyaWFuZ2xlcy5sZW5ndGgpXG4gICAgICAgIFxuICAgICAgICBzZXRNZXNoKHsgcG9pbnRzLCB0cmlhbmdsZXMgfSlcbiAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICBjb25zb2xlLmVycm9yKCd1c2VJbWFnZU1lc2ggZXJyb3I6JywgZXJyKVxuICAgICAgICBzZXRFcnJvcihlcnIgaW5zdGFuY2VvZiBFcnJvciA/IGVyci5tZXNzYWdlIDogJ1Vua25vd24gZXJyb3InKVxuICAgICAgICAvLyBGYWxsYmFjayB0byBlbXB0eSBtZXNoXG4gICAgICAgIHNldE1lc2goeyBwb2ludHM6IFtdLCB0cmlhbmdsZXM6IFtdIH0pXG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICBzZXRJc0xvYWRpbmcoZmFsc2UpXG4gICAgICB9XG4gICAgfVxuXG4gICAgcHJvY2Vzc0ltYWdlKClcbiAgfSwgW2ltYWdlU3JjLCB3aWR0aCwgaGVpZ2h0LCBlZGdlVGhyZXNob2xkLCBwb2ludERlbnNpdHksIG1heFBvaW50c10pXG5cbiAgcmV0dXJuIHsgbWVzaCwgaXNMb2FkaW5nLCBlcnJvciB9XG59XG4iXSwibmFtZXMiOlsidXNlU3RhdGUiLCJ1c2VFZmZlY3QiLCJTT0JFTF9YIiwiU09CRUxfWSIsImdldFBpeGVsR3JheXNjYWxlIiwiaW1hZ2VEYXRhIiwieCIsInkiLCJpZHgiLCJ3aWR0aCIsInIiLCJkYXRhIiwiZyIsImIiLCJhcHBseUtlcm5lbCIsImtlcm5lbCIsInN1bSIsImt5Iiwia3giLCJweCIsIk1hdGgiLCJtaW4iLCJtYXgiLCJweSIsImhlaWdodCIsImdyYXkiLCJkZXRlY3RFZGdlcyIsImVkZ2VzIiwiRmxvYXQzMkFycmF5IiwiZ3giLCJneSIsIm1hZ25pdHVkZSIsInNxcnQiLCJzYW1wbGVFZGdlUG9pbnRzIiwidGhyZXNob2xkIiwiZGVuc2l0eSIsIm1heFBvaW50cyIsInBvaW50cyIsInN0ZXAiLCJmbG9vciIsImVkZ2VWYWx1ZSIsImppdHRlclgiLCJyYW5kb20iLCJqaXR0ZXJZIiwicHVzaCIsImlkIiwibGVuZ3RoIiwiYm91bmRhcnlTdGVwIiwiYm91bmRhcnlDb3VudCIsImVkZ2VQb2ludHMiLCJzbGljZSIsImJvdW5kYXJ5UG9pbnRzIiwic2FtcGxlZEVkZ2UiLCJzb3J0IiwibWFwIiwicCIsImkiLCJkZWxhdW5heVRyaWFuZ3VsYXRlIiwibWFyZ2luIiwic3VwZXJUcmlhbmdsZSIsInAxIiwicDIiLCJwMyIsInRyaWFuZ2xlcyIsInBvaW50IiwiYmFkVHJpYW5nbGVzIiwidHJpYW5nbGUiLCJpc1BvaW50SW5DaXJjdW1jaXJjbGUiLCJwb2x5Z29uIiwiZWRnZSIsImlzU2hhcmVkIiwib3RoZXIiLCJoYXNFZGdlIiwiZmlsdGVyIiwidCIsImluY2x1ZGVzIiwiYXgiLCJheSIsImJ4IiwiYnkiLCJjeCIsImN5IiwiZGV0IiwiaGFzUDEiLCJoYXNQMiIsInVzZUltYWdlTWVzaCIsImNvbmZpZyIsImltYWdlU3JjIiwiZWRnZVRocmVzaG9sZCIsInBvaW50RGVuc2l0eSIsIm1lc2giLCJzZXRNZXNoIiwiaXNMb2FkaW5nIiwic2V0SXNMb2FkaW5nIiwiZXJyb3IiLCJzZXRFcnJvciIsInByb2Nlc3NJbWFnZSIsImltZyIsIkltYWdlIiwic3RhcnRzV2l0aCIsImNyb3NzT3JpZ2luIiwiUHJvbWlzZSIsInJlc29sdmUiLCJyZWplY3QiLCJvbmxvYWQiLCJjb25zb2xlIiwibG9nIiwib25lcnJvciIsImUiLCJFcnJvciIsInNyYyIsImNhbnZhcyIsImRvY3VtZW50IiwiY3JlYXRlRWxlbWVudCIsImN0eCIsImdldENvbnRleHQiLCJkcmF3SW1hZ2UiLCJnZXRJbWFnZURhdGEiLCJlcnIiLCJtZXNzYWdlIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./components/portrait/useImageMesh.ts\n"));

/***/ })

});